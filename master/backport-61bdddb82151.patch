From 61bdddb82151fbf51c58f6ebc1b4a687942c45a8 Mon Sep 17 00:00:00 2001
From: Razvan Cojocaru <rcojocaru@bitdefender.com>
Date: Thu, 28 Jun 2018 10:54:01 +0300
Subject: [PATCH] xen/altp2m: set access_required properly for all altp2ms

For the hostp2m, access_required starts off as 0, then it can be
set with xc_domain_set_access_required(). However, all the altp2ms
set it to 1 on init, and ignore both the hostp2m and the hypercall.
This patch sets access_required to the value from the hostp2m
on altp2m init, and propagates the values received via hypercall
to all the active altp2ms, when applicable.

Signed-off-by: Razvan Cojocaru <rcojocaru@bitdefender.com>
Acked-by: Tamas K Lengyel <tamas@tklengyel.com>
Reviewed-by: George Dunlap <george.dunlap@citrix.com>
Acked-by: Julien Grall <julien.grall@arm.com>
diff --git a/xen/arch/arm/mem_access.c b/xen/arch/arm/mem_access.c
index ae2686f..ba4ec78 100644
--- a/xen/arch/arm/mem_access.c
+++ b/xen/arch/arm/mem_access.c
@@ -453,6 +453,12 @@ int p2m_get_mem_access(struct domain *d, gfn_t gfn,
     return ret;
 }
 
+void arch_p2m_set_access_required(struct domain *d, bool access_required)
+{
+    ASSERT(atomic_read(&d->pause_count));
+    p2m_get_hostp2m(d)->access_required = access_required;
+}
+
 /*
  * Local variables:
  * mode: C
diff --git a/xen/arch/x86/mm/mem_access.c b/xen/arch/x86/mm/mem_access.c
index d8a4ea4..1bca934 100644
--- a/xen/arch/x86/mm/mem_access.c
+++ b/xen/arch/x86/mm/mem_access.c
@@ -467,6 +467,26 @@ int p2m_get_mem_access(struct domain *d, gfn_t gfn, xenmem_access_t *access)
     return _p2m_get_mem_access(p2m, gfn, access);
 }
 
+void arch_p2m_set_access_required(struct domain *d, bool access_required)
+{
+    unsigned int i;
+
+    ASSERT(atomic_read(&d->pause_count));
+
+    p2m_get_hostp2m(d)->access_required = access_required;
+
+    if ( !altp2m_active(d) )
+        return;
+
+    for ( i = 0; i < MAX_ALTP2M; i++ )
+    {
+        struct p2m_domain *p2m = d->arch.altp2m_p2m[i];
+
+        if ( p2m )
+            p2m->access_required = access_required;
+    }
+}
+
 /*
  * Local variables:
  * mode: C
diff --git a/xen/arch/x86/mm/p2m.c b/xen/arch/x86/mm/p2m.c
index c53cab4..8e9fbb5 100644
--- a/xen/arch/x86/mm/p2m.c
+++ b/xen/arch/x86/mm/p2m.c
@@ -199,6 +199,7 @@ static int p2m_init_altp2m(struct domain *d)
 {
     unsigned int i;
     struct p2m_domain *p2m;
+    struct p2m_domain *hostp2m = p2m_get_hostp2m(d);
 
     mm_lock_init(&d->arch.altp2m_list_lock);
     for ( i = 0; i < MAX_ALTP2M; i++ )
@@ -210,7 +211,7 @@ static int p2m_init_altp2m(struct domain *d)
             return -ENOMEM;
         }
         p2m->p2m_class = p2m_alternate;
-        p2m->access_required = 1;
+        p2m->access_required = hostp2m->access_required;
         _atomic_set(&p2m->active_vcpus, 0);
     }
 
diff --git a/xen/common/domctl.c b/xen/common/domctl.c
index 9b7bc08..789b30d 100644
--- a/xen/common/domctl.c
+++ b/xen/common/domctl.c
@@ -1092,8 +1092,8 @@ long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
         else
         {
             domain_pause(d);
-            p2m_get_hostp2m(d)->access_required =
-                op->u.access_required.access_required;
+            arch_p2m_set_access_required(d,
+                op->u.access_required.access_required);
             domain_unpause(d);
         }
         break;
diff --git a/xen/include/xen/domain.h b/xen/include/xen/domain.h
index 177cb35..f35e360 100644
--- a/xen/include/xen/domain.h
+++ b/xen/include/xen/domain.h
@@ -66,6 +66,8 @@ void arch_domain_unpause(struct domain *d);
 
 int arch_domain_soft_reset(struct domain *d);
 
+void arch_p2m_set_access_required(struct domain *d, bool access_required);
+
 int arch_set_info_guest(struct vcpu *, vcpu_guest_context_u);
 void arch_get_info_guest(struct vcpu *, vcpu_guest_context_u);
 

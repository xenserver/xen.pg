diff --git a/tools/misc/xen-spec-ctrl.c b/tools/misc/xen-spec-ctrl.c
index 190287a..d5a7424 100644
--- a/tools/misc/xen-spec-ctrl.c
+++ b/tools/misc/xen-spec-ctrl.c
@@ -10,7 +10,7 @@ void show_help(void)
 {
     fprintf(stderr,
             "xen-spec-ctrl: Xen speculation control tool\n"
-            "Usage: xen-spec-ctrl update\n");
+            "Usage: xen-spec-ctrl { update | exec-sp-{on|off} }\n");
 }
 
 int main(int argc, char *argv[])
@@ -19,20 +19,25 @@ int main(int argc, char *argv[])
     struct xen_sysctl sysctl = {0};
     xc_interface *xch;
 
-    if ( argc < 2 || strcmp(argv[1], "update") != 0 )
-    {
-        show_help();
-        return 1;
-    }
+    if ( argc < 2 )
+        goto help;
+
+    sysctl.interface_version = XEN_SYSCTL_INTERFACE_VERSION;
+    sysctl.cmd = XEN_SYSCTL_spec_ctrl;
+
+    if ( strcmp(argv[1], "update") == 0 )
+        sysctl.u.spec_ctrl.op = XENPF_spec_ctrl_update;
+    else if ( strcmp(argv[1], "exec-sp-on") == 0 )
+        sysctl.u.spec_ctrl.op = XENPF_spec_ctrl_exec_sp_on;
+    else if ( strcmp(argv[1], "exec-sp-off") == 0 )
+        sysctl.u.spec_ctrl.op = XENPF_spec_ctrl_exec_sp_off;
+    else
+        goto help;
 
     xch = xc_interface_open(NULL, NULL, 0);
     if ( xch == NULL )
         err(1, "xc_interface_open");
 
-    sysctl.interface_version = XEN_SYSCTL_INTERFACE_VERSION;
-    sysctl.cmd = XEN_SYSCTL_spec_ctrl;
-    sysctl.u.spec_ctrl.op = XENPF_spec_ctrl_update;
-
     ret = xc_sysctl(xch, &sysctl);
     if ( ret != 0 )
         perror("Hypercall failed");
@@ -42,8 +47,7 @@ int main(int argc, char *argv[])
         switch (sysctl.u.spec_ctrl.status)
         {
             case XENPF_spec_ctrl_success:
-                str = "Mitigations have been updated! "
-                      "Check xen-cpuid output for the details.";
+                str = "Mitigations have been updated!";
                 break;
 
             case XENPF_spec_ctrl_noop:
@@ -66,4 +70,8 @@ int main(int argc, char *argv[])
     xc_interface_close(xch);
 
     return 0;
+help:
+    show_help();
+
+    return 1;
 }
diff --git a/xen/arch/x86/hvm/vmx/vmx.c b/xen/arch/x86/hvm/vmx/vmx.c
index a361ef4..dc17437 100644
--- a/xen/arch/x86/hvm/vmx/vmx.c
+++ b/xen/arch/x86/hvm/vmx/vmx.c
@@ -2449,7 +2449,7 @@ static void __init bdw_erratum_bdf14_fixup_check(void);
  * Calculate whether the CPU is vulnerable to Instruction Fetch page
  * size-change MCEs.
  */
-static bool __init has_if_pschange_mc(void)
+static bool has_if_pschange_mc(void)
 {
     uint64_t caps = 0;
 
@@ -2541,6 +2541,11 @@ static bool __init has_if_pschange_mc(void)
     }
 }
 
+bool cpu_has_if_pschange_mc(void)
+{
+    return has_if_pschange_mc();
+}
+
 const struct hvm_function_table * __init start_vmx(void)
 {
     set_in_cr4(X86_CR4_VMXE);
diff --git a/xen/arch/x86/mm/p2m.c b/xen/arch/x86/mm/p2m.c
index 10347c0..016e0ab 100644
--- a/xen/arch/x86/mm/p2m.c
+++ b/xen/arch/x86/mm/p2m.c
@@ -280,6 +280,15 @@ void p2m_change_entry_type_global(struct domain *d,
     p2m_unlock(p2m);
 }
 
+void p2m_entry_type_recalc_global(struct domain *d, p2m_type_t t)
+{
+    struct p2m_domain *p2m = p2m_get_hostp2m(d);
+
+    p2m_lock(p2m);
+    p2m->change_entry_type_global(p2m, t, t);
+    p2m_unlock(p2m);
+}
+
 void p2m_memory_type_changed(struct domain *d)
 {
     struct p2m_domain *p2m = p2m_get_hostp2m(d);
diff --git a/xen/arch/x86/spec_ctrl.c b/xen/arch/x86/spec_ctrl.c
index 86f490b..e75d1f9 100644
--- a/xen/arch/x86/spec_ctrl.c
+++ b/xen/arch/x86/spec_ctrl.c
@@ -21,6 +21,7 @@
 #include <xen/init.h>
 #include <xen/lib.h>
 #include <xen/stop_machine.h>
+#include <xen/sched.h>
 
 #include <public/platform.h>
 
@@ -32,6 +33,8 @@
 #include <asm/setup.h>
 #include <asm/spec_ctrl.h>
 #include <asm/spec_ctrl_asm.h>
+#include <asm/hvm/vmx/vmx.h>
+#include <asm/p2m.h>
 
 /* Cmdline controls for Xen's alternative blocks. */
 static bool_t __initdata opt_msr_sc_pv = 1;
@@ -1273,13 +1276,32 @@ static int do_x86_caps_update(void *unused)
     return 0;
 }
 
+static int do_exec_sp_control(uint32_t op)
+{
+    struct domain *d;
+    bool cpu_has_bug_pschange_mc = cpu_has_if_pschange_mc();
+
+    opt_ept_exec_sp = (op == XENPF_spec_ctrl_exec_sp_on) ?
+                      true : !cpu_has_bug_pschange_mc;
+    if ( cpu_has_bug_pschange_mc )
+        printk("VMX: %s executable EPT superpages per request\n",
+               !opt_ept_exec_sp ? "Disabling" : "Enabling");
+
+    rcu_read_lock(&domlist_read_lock);
+    for_each_domain ( d )
+        if ( paging_mode_hap(d) )
+            p2m_entry_type_recalc_global(d, p2m_ram_rw);
+    rcu_read_unlock(&domlist_read_lock);
+
+    *spec_ctrl_status = XENPF_spec_ctrl_success;
+
+    return 0;
+}
+
 int spec_ctrl_do_op(uint32_t op, uint32_t *status)
 {
     int ret = 0;
 
-    if ( op != XENPF_spec_ctrl_update )
-        return -EINVAL;
-
     if ( !get_cpu_maps() )
         return -EBUSY;
 
@@ -1292,7 +1314,19 @@ int spec_ctrl_do_op(uint32_t op, uint32_t *status)
 
     common_caps = 0;
 
-    ret = stop_machine_run(do_x86_caps_update, NULL, NR_CPUS);
+    switch ( op )
+    {
+    case XENPF_spec_ctrl_update:
+        ret = stop_machine_run(do_x86_caps_update, NULL, NR_CPUS);
+        break;
+    case XENPF_spec_ctrl_exec_sp_on:
+    case XENPF_spec_ctrl_exec_sp_off:
+        ret = do_exec_sp_control(op);
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
 
     put_cpu_maps();
 
diff --git a/xen/include/asm-x86/hvm/vmx/vmx.h b/xen/include/asm-x86/hvm/vmx/vmx.h
index 98d383b..9bfbc30 100644
--- a/xen/include/asm-x86/hvm/vmx/vmx.h
+++ b/xen/include/asm-x86/hvm/vmx/vmx.h
@@ -28,6 +28,7 @@
 #include <asm/hvm/trace.h>
 #include <asm/hvm/vmx/vmcs.h>
 
+bool cpu_has_if_pschange_mc(void);
 extern int8_t opt_ept_exec_sp;
 
 typedef union {
diff --git a/xen/include/asm-x86/p2m.h b/xen/include/asm-x86/p2m.h
index f1bce4d..a99fe95 100644
--- a/xen/include/asm-x86/p2m.h
+++ b/xen/include/asm-x86/p2m.h
@@ -578,6 +578,8 @@ void p2m_flush_hardware_cached_dirty(struct domain *d);
 void p2m_change_entry_type_global(struct domain *d, 
                                   p2m_type_t ot, p2m_type_t nt);
 
+void p2m_entry_type_recalc_global(struct domain *d, p2m_type_t t);
+
 /* Change types across a range of p2m entries (start ... end-1) */
 void p2m_change_type_range(struct domain *d, 
                            unsigned long start, unsigned long end,
diff --git a/xen/include/public/sysctl.h b/xen/include/public/sysctl.h
index 5a3fc05..5a52e83 100644
--- a/xen/include/public/sysctl.h
+++ b/xen/include/public/sysctl.h
@@ -1034,6 +1034,10 @@ DEFINE_XEN_GUEST_HANDLE(xen_sysctl_livepatch_op_t);
 
 struct xen_sysctl_spec_ctrl {
 #define XENPF_spec_ctrl_update  0 /* Try to use new mitigations */
+/* Turn executable EPT superpage shattering on */
+#define XENPF_spec_ctrl_exec_sp_on  1
+/* Turn executable EPT superpage shattering off */
+#define XENPF_spec_ctrl_exec_sp_off 2
     uint32_t op;      /* IN */
 #define XENPF_spec_ctrl_success 0 /* New mitigations have been applied.       */
                                   /* This is returned in case if some H/W     */

From 78b1225ea52e3baaa18533e01182e4de6bd457a5 Mon Sep 17 00:00:00 2001
From: Paul Durrant <paul.durrant@citrix.com>
Date: Mon, 5 Nov 2018 11:09:35 +0100
Subject: [PATCH] viridian: remove MSR perf counters

They're not really useful so maintaining them is pointless.

Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Reviewed-by: Roger Pau Monne <roger.pau@citrix.com>
diff --git a/xen/arch/x86/hvm/viridian/viridian.c b/xen/arch/x86/hvm/viridian/viridian.c
index f3d6ee8c9f..592a7fdf60 100644
--- a/xen/arch/x86/hvm/viridian/viridian.c
+++ b/xen/arch/x86/hvm/viridian/viridian.c
@@ -11,7 +11,6 @@
 
 #include <xen/sched.h>
 #include <xen/version.h>
-#include <xen/perfc.h>
 #include <xen/hypercall.h>
 #include <xen/domain_page.h>
 #include <asm/guest_access.h>
@@ -563,13 +562,11 @@ static int guest_wrmsr_viridian(struct vcpu *v, uint32_t idx, uint64_t val)
     switch ( idx )
     {
     case HV_X64_MSR_GUEST_OS_ID:
-        perfc_incr(mshv_wrmsr_osid);
         d->arch.hvm.viridian.guest_os_id.raw = val;
         dump_guest_os_id(d);
         break;
 
     case HV_X64_MSR_HYPERCALL:
-        perfc_incr(mshv_wrmsr_hc_page);
         d->arch.hvm.viridian.hypercall_gpa.raw = val;
         dump_hypercall(d);
         if ( d->arch.hvm.viridian.hypercall_gpa.fields.enabled )
@@ -577,18 +574,15 @@ static int guest_wrmsr_viridian(struct vcpu *v, uint32_t idx, uint64_t val)
         break;
 
     case HV_X64_MSR_VP_INDEX:
-        perfc_incr(mshv_wrmsr_vp_index);
         break;
 
     case HV_X64_MSR_EOI:
-        perfc_incr(mshv_wrmsr_eoi);
         vlapic_EOI_set(vcpu_vlapic(v));
         break;
 
     case HV_X64_MSR_ICR: {
         u32 eax = (u32)val, edx = (u32)(val >> 32);
         struct vlapic *vlapic = vcpu_vlapic(v);
-        perfc_incr(mshv_wrmsr_icr);
         eax &= ~(1 << 12);
         edx &= 0xff000000;
         vlapic_set_reg(vlapic, APIC_ICR2, edx);
@@ -598,12 +592,10 @@ static int guest_wrmsr_viridian(struct vcpu *v, uint32_t idx, uint64_t val)
     }
 
     case HV_X64_MSR_TPR:
-        perfc_incr(mshv_wrmsr_tpr);
         vlapic_set_reg(vcpu_vlapic(v), APIC_TASKPRI, (uint8_t)val);
         break;
 
     case HV_X64_MSR_VP_ASSIST_PAGE:
-        perfc_incr(mshv_wrmsr_apic_msr);
         teardown_vp_assist(v); /* release any previous mapping */
         v->arch.hvm.viridian.vp_assist.msr.raw = val;
         dump_vp_assist(v);
@@ -615,7 +607,6 @@ static int guest_wrmsr_viridian(struct vcpu *v, uint32_t idx, uint64_t val)
         if ( !(viridian_feature_mask(d) & HVMPV_reference_tsc) )
             return X86EMUL_EXCEPTION;
 
-        perfc_incr(mshv_wrmsr_tsc_msr);
         d->arch.hvm.viridian.reference_tsc.raw = val;
         dump_reference_tsc(d);
         if ( d->arch.hvm.viridian.reference_tsc.fields.enabled )
@@ -719,17 +710,14 @@ static int guest_rdmsr_viridian(const struct vcpu *v, uint32_t idx,
     switch ( idx )
     {
     case HV_X64_MSR_GUEST_OS_ID:
-        perfc_incr(mshv_rdmsr_osid);
         *val = d->arch.hvm.viridian.guest_os_id.raw;
         break;
 
     case HV_X64_MSR_HYPERCALL:
-        perfc_incr(mshv_rdmsr_hc_page);
         *val = d->arch.hvm.viridian.hypercall_gpa.raw;
         break;
 
     case HV_X64_MSR_VP_INDEX:
-        perfc_incr(mshv_rdmsr_vp_index);
         *val = v->vcpu_id;
         break;
 
@@ -737,7 +725,6 @@ static int guest_rdmsr_viridian(const struct vcpu *v, uint32_t idx,
         if ( viridian_feature_mask(d) & HVMPV_no_freq )
             return X86EMUL_EXCEPTION;
 
-        perfc_incr(mshv_rdmsr_tsc_frequency);
         *val = (uint64_t)d->arch.tsc_khz * 1000ull;
         break;
 
@@ -745,23 +732,19 @@ static int guest_rdmsr_viridian(const struct vcpu *v, uint32_t idx,
         if ( viridian_feature_mask(d) & HVMPV_no_freq )
             return X86EMUL_EXCEPTION;
 
-        perfc_incr(mshv_rdmsr_apic_frequency);
         *val = 1000000000ull / APIC_BUS_CYCLE_NS;
         break;
 
     case HV_X64_MSR_ICR:
-        perfc_incr(mshv_rdmsr_icr);
         *val = (((uint64_t)vlapic_get_reg(vcpu_vlapic(v), APIC_ICR2) << 32) |
                 vlapic_get_reg(vcpu_vlapic(v), APIC_ICR));
         break;
 
     case HV_X64_MSR_TPR:
-        perfc_incr(mshv_rdmsr_tpr);
         *val = vlapic_get_reg(vcpu_vlapic(v), APIC_TASKPRI);
         break;
 
     case HV_X64_MSR_VP_ASSIST_PAGE:
-        perfc_incr(mshv_rdmsr_apic_msr);
         *val = v->arch.hvm.viridian.vp_assist.msr.raw;
         break;
 
@@ -769,7 +752,6 @@ static int guest_rdmsr_viridian(const struct vcpu *v, uint32_t idx,
         if ( !(viridian_feature_mask(d) & HVMPV_reference_tsc) )
             return X86EMUL_EXCEPTION;
 
-        perfc_incr(mshv_rdmsr_tsc_msr);
         *val = d->arch.hvm.viridian.reference_tsc.raw;
         break;
 
@@ -786,7 +768,6 @@ static int guest_rdmsr_viridian(const struct vcpu *v, uint32_t idx,
             printk(XENLOG_G_INFO "d%d: VIRIDIAN MSR_TIME_REF_COUNT: accessed\n",
                    d->domain_id);
 
-        perfc_incr(mshv_rdmsr_time_ref_count);
         *val = raw_trc_val(d) + trc->off;
         break;
     }
@@ -902,7 +883,6 @@ int viridian_hypercall(struct cpu_user_regs *regs)
         /*
          * See section 14.5.1 of the specification.
          */
-        perfc_incr(mshv_call_long_wait);
         do_sched_op(SCHEDOP_yield, guest_handle_from_ptr(NULL, void));
         status = HV_STATUS_SUCCESS;
         break;
@@ -921,7 +901,6 @@ int viridian_hypercall(struct cpu_user_regs *regs)
         /*
          * See sections 9.4.2 and 9.4.4 of the specification.
          */
-        perfc_incr(mshv_call_flush);
 
         /* These hypercalls should never use the fast-call convention. */
         status = HV_STATUS_INVALID_PARAMETER;
diff --git a/xen/include/asm-x86/perfc_defn.h b/xen/include/asm-x86/perfc_defn.h
index 6db8746906..1a9ea3f89e 100644
--- a/xen/include/asm-x86/perfc_defn.h
+++ b/xen/include/asm-x86/perfc_defn.h
@@ -112,32 +112,6 @@ PERFCOUNTER(shadow_unsync,         "shadow OOS unsyncs")
 PERFCOUNTER(shadow_unsync_evict,   "shadow OOS evictions")
 PERFCOUNTER(shadow_resync,         "shadow OOS resyncs")
 
-PERFCOUNTER(mshv_call_sw_addr_space,    "MS Hv Switch Address Space")
-PERFCOUNTER(mshv_call_flush_tlb_list,   "MS Hv Flush TLB list")
-PERFCOUNTER(mshv_call_flush_tlb_all,    "MS Hv Flush TLB all")
-PERFCOUNTER(mshv_call_long_wait,        "MS Hv Notify long wait")
-PERFCOUNTER(mshv_call_flush,            "MS Hv Flush TLB")
-PERFCOUNTER(mshv_rdmsr_osid,            "MS Hv rdmsr Guest OS ID")
-PERFCOUNTER(mshv_rdmsr_hc_page,         "MS Hv rdmsr hypercall page")
-PERFCOUNTER(mshv_rdmsr_vp_index,        "MS Hv rdmsr vp index")
-PERFCOUNTER(mshv_rdmsr_tsc_frequency,   "MS Hv rdmsr TSC frequency")
-PERFCOUNTER(mshv_rdmsr_apic_frequency,  "MS Hv rdmsr APIC frequency")
-PERFCOUNTER(mshv_rdmsr_time_ref_count,  "MS Hv rdmsr time ref count")
-PERFCOUNTER(mshv_rdmsr_icr,             "MS Hv rdmsr icr")
-PERFCOUNTER(mshv_rdmsr_tpr,             "MS Hv rdmsr tpr")
-PERFCOUNTER(mshv_rdmsr_apic_assist,     "MS Hv rdmsr APIC assist")
-PERFCOUNTER(mshv_rdmsr_apic_msr,        "MS Hv rdmsr APIC msr")
-PERFCOUNTER(mshv_rdmsr_tsc_msr,         "MS Hv rdmsr TSC msr")
-PERFCOUNTER(mshv_wrmsr_osid,            "MS Hv wrmsr Guest OS ID")
-PERFCOUNTER(mshv_wrmsr_hc_page,         "MS Hv wrmsr hypercall page")
-PERFCOUNTER(mshv_wrmsr_vp_index,        "MS Hv wrmsr vp index")
-PERFCOUNTER(mshv_wrmsr_icr,             "MS Hv wrmsr icr")
-PERFCOUNTER(mshv_wrmsr_tpr,             "MS Hv wrmsr tpr")
-PERFCOUNTER(mshv_wrmsr_eoi,             "MS Hv wrmsr eoi")
-PERFCOUNTER(mshv_wrmsr_apic_assist,     "MS Hv wrmsr APIC assist")
-PERFCOUNTER(mshv_wrmsr_apic_msr,        "MS Hv wrmsr APIC msr")
-PERFCOUNTER(mshv_wrmsr_tsc_msr,         "MS Hv wrmsr TSC msr")
-
 PERFCOUNTER(realmode_emulations, "realmode instructions emulated")
 PERFCOUNTER(realmode_exits,      "vmexits from realmode")
 

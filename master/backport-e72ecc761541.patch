From e72ecc7615410e5bf1a1c9a4c7772322c16eeb82 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Thu, 17 Jan 2019 12:26:17 +0000
Subject: [PATCH] x86/altp2m: Rework #VE enable/disable paths

Split altp2m_vcpu_{enable,disable}_ve() out of the
HVMOP_altp2m_vcpu_{enable,disable}_notify marshalling logic.  A future change
is going to need to call altp2m_vcpu_disable_ve() from the domain_kill() path.

While at it, clean up the logic in altp2m_vcpu_{initialise,destroy}().
altp2m_vcpu_reset() has no external callers, so fold it into its two
callsites.  This in turn allows for altp2m_vcpu_destroy() to reuse
altp2m_vcpu_disable_ve() rather than opencoding it.

No practical change.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Razvan Cojocaru <rcojocaru@bitdefender.com>
Acked-by: Jan Beulich <jbeulich@suse.com>
Release-acked-by: Juergen Gross <jgross@suse.com>
diff --git a/xen/arch/x86/hvm/hvm.c b/xen/arch/x86/hvm/hvm.c
index 8b0217b..730f60c 100644
--- a/xen/arch/x86/hvm/hvm.c
+++ b/xen/arch/x86/hvm/hvm.c
@@ -4587,7 +4587,6 @@ static int do_altp2m_op(
     case HVMOP_altp2m_vcpu_enable_notify:
     {
         struct vcpu *v;
-        p2m_type_t p2mt;
 
         if ( a.u.enable_notify.pad ||
              a.u.enable_notify.vcpu_id >= d->max_vcpus )
@@ -4604,16 +4603,7 @@ static int do_altp2m_op(
 
         v = d->vcpu[a.u.enable_notify.vcpu_id];
 
-        if ( !gfn_eq(vcpu_altp2m(v).veinfo_gfn, INVALID_GFN) ||
-             mfn_eq(get_gfn_query_unlocked(v->domain,
-                    a.u.enable_notify.gfn, &p2mt), INVALID_MFN) )
-        {
-            rc = -EINVAL;
-            break;
-        }
-
-        vcpu_altp2m(v).veinfo_gfn = _gfn(a.u.enable_notify.gfn);
-        altp2m_vcpu_update_vmfunc_ve(v);
+        rc = altp2m_vcpu_enable_ve(v, _gfn(a.u.enable_notify.gfn));
         break;
     }
 
@@ -4635,12 +4625,7 @@ static int do_altp2m_op(
 
         v = d->vcpu[a.u.enable_notify.vcpu_id];
 
-        /* Already disabled, nothing to do. */
-        if ( gfn_eq(vcpu_altp2m(v).veinfo_gfn, INVALID_GFN) )
-            break;
-
-        vcpu_altp2m(v).veinfo_gfn = INVALID_GFN;
-        altp2m_vcpu_update_vmfunc_ve(v);
+        altp2m_vcpu_disable_ve(v);
         break;
     }
 
diff --git a/xen/arch/x86/mm/altp2m.c b/xen/arch/x86/mm/altp2m.c
index 930bdc2..8bdefb0 100644
--- a/xen/arch/x86/mm/altp2m.c
+++ b/xen/arch/x86/mm/altp2m.c
@@ -21,22 +21,13 @@
 #include <asm/altp2m.h>
 
 void
-altp2m_vcpu_reset(struct vcpu *v)
-{
-    struct altp2mvcpu *av = &vcpu_altp2m(v);
-
-    av->p2midx = INVALID_ALTP2M;
-    av->veinfo_gfn = INVALID_GFN;
-}
-
-void
 altp2m_vcpu_initialise(struct vcpu *v)
 {
     if ( v != current )
         vcpu_pause(v);
 
-    altp2m_vcpu_reset(v);
     vcpu_altp2m(v).p2midx = 0;
+    vcpu_altp2m(v).veinfo_gfn = INVALID_GFN;
     atomic_inc(&p2m_get_altp2m(v)->active_vcpus);
 
     altp2m_vcpu_update_p2m(v);
@@ -56,15 +47,39 @@ altp2m_vcpu_destroy(struct vcpu *v)
     if ( (p2m = p2m_get_altp2m(v)) )
         atomic_dec(&p2m->active_vcpus);
 
-    altp2m_vcpu_reset(v);
+    altp2m_vcpu_disable_ve(v);
 
+    vcpu_altp2m(v).p2midx = INVALID_ALTP2M;
     altp2m_vcpu_update_p2m(v);
-    altp2m_vcpu_update_vmfunc_ve(v);
 
     if ( v != current )
         vcpu_unpause(v);
 }
 
+int altp2m_vcpu_enable_ve(struct vcpu *v, gfn_t gfn)
+{
+    p2m_type_t p2mt;
+
+    if ( !gfn_eq(vcpu_altp2m(v).veinfo_gfn, INVALID_GFN) ||
+         mfn_eq(get_gfn_query_unlocked(v->domain, gfn_x(gfn), &p2mt),
+                INVALID_MFN) )
+        return -EINVAL;
+
+    vcpu_altp2m(v).veinfo_gfn = gfn;
+    altp2m_vcpu_update_vmfunc_ve(v);
+
+    return 0;
+}
+
+void altp2m_vcpu_disable_ve(struct vcpu *v)
+{
+    if ( !gfn_eq(vcpu_altp2m(v).veinfo_gfn, INVALID_GFN) )
+    {
+        vcpu_altp2m(v).veinfo_gfn = INVALID_GFN;
+        altp2m_vcpu_update_vmfunc_ve(v);
+    }
+}
+
 /*
  * Local variables:
  * mode: C
diff --git a/xen/include/asm-x86/altp2m.h b/xen/include/asm-x86/altp2m.h
index 64c7618..33d50f2 100644
--- a/xen/include/asm-x86/altp2m.h
+++ b/xen/include/asm-x86/altp2m.h
@@ -31,7 +31,9 @@ static inline bool_t altp2m_active(const struct domain *d)
 /* Alternate p2m VCPU */
 void altp2m_vcpu_initialise(struct vcpu *v);
 void altp2m_vcpu_destroy(struct vcpu *v);
-void altp2m_vcpu_reset(struct vcpu *v);
+
+int altp2m_vcpu_enable_ve(struct vcpu *v, gfn_t gfn);
+void altp2m_vcpu_disable_ve(struct vcpu *v);
 
 static inline uint16_t altp2m_vcpu_idx(const struct vcpu *v)
 {

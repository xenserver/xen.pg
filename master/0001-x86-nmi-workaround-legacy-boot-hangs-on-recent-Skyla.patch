From 5bf28e34358bbe325d5ef2f3774f2e409c77d601 Mon Sep 17 00:00:00 2001
From: Igor Druzhinin <igor.druzhinin@citrix.com>
Date: Wed, 14 Feb 2018 14:54:01 +0000
Subject: [PATCH] x86/nmi: workaround legacy boot hangs on recent Skylake
 firmware

We're noticing a reproducible system boot hang on certain
Skylake platforms where the BIOS is configured in legacy
boot mode with x2APIC disabled. The system stalls immediately
after writing the first SMP initialization sequence into APIC ICR.

The cause of the problem is watchdog NMI handler execution -
somewhere near the end of NMI handling (after it's already
rescheduled the next NMI) it tries to access IO port 0x61
to get the actual NMI reason on CPU0. Unfortunately, this
port is emulated by BIOS using SMIs and this emulation
apparently might take more than we expect under certain
conditions. As the result, the system is constantly moving
between NMI and SMI handler and not making any progress.

Just lower the initial frequency for now as we lower it later
even more anyway. Additionally, move IO port access before
NMI re-scheduling.

Signed-off-by: Igor Druzhinin <igor.druzhinin@citrix.com>
diff --git a/xen/arch/x86/nmi.c b/xen/arch/x86/nmi.c
index 617e4f7..262e9ac 100644
--- a/xen/arch/x86/nmi.c
+++ b/xen/arch/x86/nmi.c
@@ -35,7 +35,8 @@
 #include <asm/apic.h>
 
 unsigned int nmi_watchdog = NMI_NONE;
-static unsigned int nmi_hz = HZ;
+/* watchdog initial frequency: Shouldn't be too high to avoid SMP boot stalls */
+static unsigned int nmi_hz = HZ / 10;
 static unsigned int nmi_perfctr_msr;	/* the MSR to reset in NMI handler */
 static unsigned int nmi_p4_cccr_val;
 static DEFINE_PER_CPU(struct timer, nmi_timer);
diff --git a/xen/arch/x86/traps.c b/xen/arch/x86/traps.c
index 1886309..cf9a8c0 100644
--- a/xen/arch/x86/traps.c
+++ b/xen/arch/x86/traps.c
@@ -3712,7 +3712,7 @@ static nmi_callback_t *nmi_callback = dummy_nmi_callback;
 void do_nmi(const struct cpu_user_regs *regs)
 {
     unsigned int cpu = smp_processor_id();
-    unsigned char reason;
+    unsigned char reason = 0;
     bool_t handle_unknown = 0;
 
     ++nmi_count(cpu);
@@ -3720,6 +3720,12 @@ void do_nmi(const struct cpu_user_regs *regs)
     if ( nmi_callback(regs, cpu) )
         return;
 
+    /* This IO port access is likely to produce SMI which, in turn,
+     * may take enough time for the next NMI tick to happen. To avoid having
+     * nested NMI as the result let's call it before watchdog re-scheduling */
+    if ( cpu == 0 )
+        reason = inb(0x61);
+
     if ( (nmi_watchdog == NMI_NONE) ||
          (!nmi_watchdog_tick(regs) && watchdog_force) )
         handle_unknown = 1;
@@ -3727,7 +3733,6 @@ void do_nmi(const struct cpu_user_regs *regs)
     /* Only the BSP gets external NMIs from the system. */
     if ( cpu == 0 )
     {
-        reason = inb(0x61);
         if ( reason & 0x80 )
             pci_serr_error(regs);
         if ( reason & 0x40 )

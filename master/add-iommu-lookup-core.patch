diff --git a/xen/drivers/passthrough/iommu.c b/xen/drivers/passthrough/iommu.c
index 37cdbc3..2f98d52 100644
--- a/xen/drivers/passthrough/iommu.c
+++ b/xen/drivers/passthrough/iommu.c
@@ -294,6 +294,29 @@ int iommu_unmap_page(struct domain *d, unsigned long gfn)
     return rc;
 }
 
+int iommu_lookup_page(struct domain *d, unsigned long bfn, unsigned long *mfn)
+{
+    struct domain_iommu *hd = dom_iommu(d);
+
+    /* BFN maps 1:1 to MFN when iommu passthrough is enabled */
+    if ( iommu_passthrough && is_hardware_domain(d) ) {
+        *mfn = bfn;
+        return 0;
+    }
+
+    /* Do not support domains with shared PT */
+    if ( iommu_use_hap_pt(d) )
+    {
+        return -ENOMEM;
+    }
+
+    if ( !iommu_enabled || !hd->platform_ops ||
+            !hd->platform_ops->lookup_page )
+        return -ENOMEM;
+
+    return hd->platform_ops->lookup_page(d, bfn, mfn);
+}
+
 static void iommu_free_pagetables(unsigned long unused)
 {
     do {
diff --git a/xen/include/xen/iommu.h b/xen/include/xen/iommu.h
index 8b23cc9..0ba7a53 100644
--- a/xen/include/xen/iommu.h
+++ b/xen/include/xen/iommu.h
@@ -77,6 +77,7 @@ void iommu_teardown(struct domain *d);
 int __must_check iommu_map_page(struct domain *d, unsigned long gfn,
                                 unsigned long mfn, unsigned int flags);
 int __must_check iommu_unmap_page(struct domain *d, unsigned long gfn);
+int iommu_lookup_page(struct domain *d, unsigned long bfn, unsigned long *mfn);
 
 enum iommu_feature
 {
@@ -169,6 +170,7 @@ struct iommu_ops {
     int __must_check (*map_page)(struct domain *d, unsigned long gfn,
                                  unsigned long mfn, unsigned int flags);
     int __must_check (*unmap_page)(struct domain *d, unsigned long gfn);
+    int (*lookup_page)(struct domain *d, unsigned long bfn, unsigned long *mfn);
     void (*free_page_table)(struct page_info *);
 #ifdef CONFIG_X86
     void (*update_ire_from_apic)(unsigned int apic, unsigned int reg, unsigned int value);

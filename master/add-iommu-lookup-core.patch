diff --git a/xen/drivers/passthrough/iommu.c b/xen/drivers/passthrough/iommu.c
index 429b5ae774..3a3ba41c37 100644
--- a/xen/drivers/passthrough/iommu.c
+++ b/xen/drivers/passthrough/iommu.c
@@ -373,6 +373,29 @@ int iommu_legacy_unmap(struct domain *d, unsigned long gfn,
     return rc;
 }
 
+int iommu_lookup_page(struct domain *d, unsigned long bfn, unsigned long *mfn)
+{
+    struct domain_iommu *hd = dom_iommu(d);
+
+    /* BFN maps 1:1 to MFN when iommu passthrough is enabled */
+    if ( iommu_passthrough && is_hardware_domain(d) ) {
+        *mfn = bfn;
+        return 0;
+    }
+
+    /* Do not support domains with shared PT */
+    if ( iommu_use_hap_pt(d) )
+    {
+        return -ENOMEM;
+    }
+
+    if ( !iommu_enabled || !hd->platform_ops ||
+            !hd->platform_ops->lookup_page )
+        return -ENOMEM;
+
+    return hd->platform_ops->lookup_page(d, bfn, mfn);
+}
+
 static void iommu_free_pagetables(unsigned long unused)
 {
     do {
diff --git a/xen/include/xen/iommu.h b/xen/include/xen/iommu.h
index e55776b825..d6ee40d46b 100644
--- a/xen/include/xen/iommu.h
+++ b/xen/include/xen/iommu.h
@@ -99,6 +99,8 @@ int __must_check iommu_iotlb_flush(struct domain *d, unsigned long gfn,
 int __must_check iommu_iotlb_flush_all(struct domain *d,
                                        unsigned int flush_flags);
 
+int iommu_lookup_page(struct domain *d, unsigned long bfn, unsigned long *mfn);
+
 enum iommu_feature
 {
     IOMMU_FEAT_COHERENT_WALK,
@@ -192,6 +194,7 @@ struct iommu_ops {
                                  unsigned int *flush_flags);
     int __must_check (*unmap_page)(struct domain *d, unsigned long gfn,
                                    unsigned int *flush_flags);
+    int (*lookup_page)(struct domain *d, unsigned long bfn, unsigned long *mfn);
     void (*free_page_table)(struct page_info *);
 #ifdef CONFIG_X86
     void (*update_ire_from_apic)(unsigned int apic, unsigned int reg, unsigned int value);

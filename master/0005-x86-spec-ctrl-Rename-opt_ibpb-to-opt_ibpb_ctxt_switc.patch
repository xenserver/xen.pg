From fb4b6882532db69193c2a1c9c1f39d6287ae7b6c Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Mon, 4 Jul 2022 21:32:17 +0100
Subject: x86/spec-ctrl: Rename opt_ibpb to opt_ibpb_ctxt_switch

We are about to introduce the use of IBPB at different points in Xen, making
opt_ibpb ambiguous.  Rename it to opt_ibpb_ctxt_switch.

No functional change.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>

diff --git a/xen/arch/x86/domain.c b/xen/arch/x86/domain.c
index 379d9890875d..db4af93bde03 100644
--- a/xen/arch/x86/domain.c
+++ b/xen/arch/x86/domain.c
@@ -2327,7 +2327,7 @@ void context_switch(struct vcpu *prev, struct vcpu *next)
 
         ctxt_switch_levelling(next);
 
-        if ( opt_ibpb && !is_idle_domain(nextd) )
+        if ( opt_ibpb_ctxt_switch && !is_idle_domain(nextd) )
         {
             static DEFINE_PER_CPU(unsigned int, last);
             unsigned int *last_id = &this_cpu(last);
diff --git a/xen/arch/x86/spec_ctrl.c b/xen/arch/x86/spec_ctrl.c
index 029f833b4605..c6841f82400e 100644
--- a/xen/arch/x86/spec_ctrl.c
+++ b/xen/arch/x86/spec_ctrl.c
@@ -55,7 +55,7 @@ static enum ind_thunk {
     THUNK_JMP,
 } opt_thunk __initdata = THUNK_DEFAULT;
 static int8_t __initdata opt_ibrs = -1;
-bool_t __read_mostly opt_ibpb = 1;
+bool_t __read_mostly opt_ibpb_ctxt_switch = 1;
 bool_t __read_mostly opt_ssbd = 0;
 int8_t __read_mostly opt_eager_fpu = -1;
 int8_t __read_mostly opt_l1d_flush = -1;
@@ -103,7 +103,7 @@ static int __init parse_bti(const char *s)
         else if ( (val = parse_boolean("ibrs", s, ss)) >= 0 )
             opt_ibrs = val;
         else if ( (val = parse_boolean("ibpb", s, ss)) >= 0 )
-            opt_ibpb = val;
+            opt_ibpb_ctxt_switch = val;
         else if ( (val = parse_boolean("rsb_native", s, ss)) >= 0 )
             opt_rsb_pv = val;
         else if ( (val = parse_boolean("rsb_vmexit", s, ss)) >= 0 )
@@ -159,7 +159,7 @@ static int __init parse_spec_ctrl(char *s)
 
             opt_thunk = THUNK_JMP;
             opt_ibrs = 0;
-            opt_ibpb = 0;
+            opt_ibpb_ctxt_switch = 0;
             opt_ssbd = 0;
             opt_l1d_flush = 0;
             opt_srb_lock = 0;
@@ -221,7 +221,7 @@ static int __init parse_spec_ctrl(char *s)
         else if ( (val = parse_boolean("ibrs", s, ss)) >= 0 )
             opt_ibrs = val;
         else if ( (val = parse_boolean("ibpb", s, ss)) >= 0 )
-            opt_ibpb = val;
+            opt_ibpb_ctxt_switch = val;
         else if ( (val = parse_boolean("ssbd", s, ss)) >= 0 )
             opt_ssbd = val;
         else if ( (val = parse_boolean("eager-fpu", s, ss)) >= 0 )
@@ -415,7 +415,7 @@ static void __init print_details(enum ind_thunk thunk, uint64_t caps)
            (opt_tsx & 1)                             ? " TSX+" : " TSX-",
            !boot_cpu_has(X86_FEATURE_SRBDS_CTRL)     ? "" :
            opt_srb_lock                              ? " SRB_LOCK+" : " SRB_LOCK-",
-           opt_ibpb                                  ? " IBPB"  : "",
+           opt_ibpb_ctxt_switch                      ? " IBPB-ctxt" : "",
            opt_l1d_flush                             ? " L1D_FLUSH" : "",
            opt_mds_pv || opt_mds_hvm ||
            opt_fb_clear_mmio                         ? " VERW"  : "",
@@ -1042,7 +1042,7 @@ void __init init_speculation_mitigations(void)
 
     /* Check we have hardware IBPB support before using it... */
     if ( !boot_cpu_has(X86_FEATURE_IBRSB) && !boot_cpu_has(X86_FEATURE_IBPB) )
-        opt_ibpb = 0;
+        opt_ibpb_ctxt_switch = 0;
 
     /* Check whether Eager FPU should be enabled by default. */
     if ( opt_eager_fpu == -1 )
diff --git a/xen/include/asm-x86/spec_ctrl.h b/xen/include/asm-x86/spec_ctrl.h
index 8d759136369b..5e95eb9c5ddb 100644
--- a/xen/include/asm-x86/spec_ctrl.h
+++ b/xen/include/asm-x86/spec_ctrl.h
@@ -27,7 +27,7 @@
 void init_speculation_mitigations(void);
 void spec_ctrl_init_domain(struct domain *d);
 
-extern bool_t opt_ibpb;
+extern bool_t opt_ibpb_ctxt_switch;
 extern bool_t opt_ssbd;
 extern int8_t opt_eager_fpu;
 extern int8_t opt_l1d_flush;

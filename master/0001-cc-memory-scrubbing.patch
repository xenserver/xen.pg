From fa872a9bbed48830f2039dbe524d26b480dcf18f Mon Sep 17 00:00:00 2001
From: Sergey Dyasli <sergey.dyasli@citrix.com>
Date: Fri, 29 Jun 2018 15:12:07 +0100
Subject: [PATCH] memory scrubbing for Common Criteria

Goal: every page from a guest must be cleared (scrubbed) before being
      given to another unprivileged guest.

Memory in Xen is generally allocated via the page allocator (common/page_alloc.c).
It supports 2 interfaces for allocation:

    1. alloc_xenheap_pages() -- usually used by Xen itself but pages can
                    be mapped to a domain by share_xen_page_with_guest()

    2. alloc_domheap_pages() -- usually used for domain's memory

Memory is freed (returned to the allocator) via appropriate free functions:

    1. free_xenheap_pages() [x86 has CONFIG_SEPARATE_XENHEAP=n]
       It scrubs every page before giving it back to the allocator.

    2. free_domheap_pages()
       It scrubs pages only under the following condition:

            scrub = d->is_dying

       i.e. only during the process of domain destruction.

In order to cover other cases, like when a guest voluntarily returns
(releases) its own memory to Xen, every page must be unconditionally
scrubbed during free_domheap_pages().

Note: it's possible to bypass the page allocator by using steal_page().
      Only GNTTABOP_transfer and XENMEM_exchange use it and they must
      be restricted by other means.

Signed-off-by: Sergey Dyasli <sergey.dyasli@citrix.com>
diff --git a/xen/common/page_alloc.c b/xen/common/page_alloc.c
index 79536ef..40c8ee7 100644
--- a/xen/common/page_alloc.c
+++ b/xen/common/page_alloc.c
@@ -2334,8 +2334,6 @@ void free_domheap_pages(struct page_info *pg, unsigned int order)
     }
     else
     {
-        bool scrub;
-
         if ( likely(d) && likely(d != dom_cow) )
         {
             /* NB. May recursively lock from relinquish_memory(). */
@@ -2350,14 +2348,6 @@ void free_domheap_pages(struct page_info *pg, unsigned int order)
             drop_dom_ref = !domain_adjust_tot_pages(d, -(1 << order));
 
             spin_unlock_recursive(&d->page_alloc_lock);
-
-            /*
-             * Normally we expect a domain to clear pages before freeing them,
-             * if it cares about the secrecy of their contents. However, after
-             * a domain has died we assume responsibility for erasure. We do
-             * scrub regardless if option scrub_domheap is set.
-             */
-            scrub = d->is_dying || scrub_debug || opt_scrub_domheap;
         }
         else
         {
@@ -2370,10 +2360,9 @@ void free_domheap_pages(struct page_info *pg, unsigned int order)
              */
             ASSERT(!d || !order);
             drop_dom_ref = false;
-            scrub = 1;
         }
 
-        free_heap_pages(pg, order, scrub);
+        free_heap_pages(pg, order, true);
     }
 
     if ( drop_dom_ref )

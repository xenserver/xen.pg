From fa872a9bbed48830f2039dbe524d26b480dcf18f Mon Sep 17 00:00:00 2001
From: Sergey Dyasli <sergey.dyasli@citrix.com>
Date: Fri, 29 Jun 2018 15:12:07 +0100
Subject: [PATCH] memory scrubbing for Common Criteria

Goal: every page from a guest must be cleared (scrubbed) before being
      given to another unprivileged guest.

Memory in Xen is generally allocated via the page allocator (common/page_alloc.c).
It supports 2 interfaces for allocation:

    1. alloc_xenheap_pages() -- usually used by Xen itself but pages can
                    be mapped to a domain by share_xen_page_with_guest()

    2. alloc_domheap_pages() -- usually used for domain's memory

Memory is freed (returned to the allocator) via appropriate free functions:

    1. free_xenheap_pages() [x86 has CONFIG_SEPARATE_XENHEAP=n]
       It scrubs every page before giving it back to the allocator.

    2. free_domheap_pages()
       It scrubs pages only under the following condition:

            scrub = d->is_dying

       i.e. only during the process of domain destruction.

In order to cover other cases, like when a guest voluntarily returns
(releases) its own memory to Xen, every page must be unconditionally
scrubbed during free_domheap_pages().

Note: it's possible to bypass the page allocator by using steal_page().
      Only GNTTABOP_transfer and XENMEM_exchange use it and they must
      be restricted by other means.

Signed-off-by: Sergey Dyasli <sergey.dyasli@citrix.com>
diff --git a/xen/common/page_alloc.c b/xen/common/page_alloc.c
index 82d3069a2d..3b8add868c 100644
--- a/xen/common/page_alloc.c
+++ b/xen/common/page_alloc.c
@@ -1847,8 +1847,6 @@ void free_domheap_pages(struct page_info *pg, unsigned int order)
     }
     else
     {
-        bool_t scrub;
-
         if ( likely(d) && likely(d != dom_cow) )
         {
             /* NB. May recursively lock from relinquish_memory(). */
@@ -1863,13 +1861,6 @@ void free_domheap_pages(struct page_info *pg, unsigned int order)
             drop_dom_ref = !domain_adjust_tot_pages(d, -(1 << order));
 
             spin_unlock_recursive(&d->page_alloc_lock);
-
-            /*
-             * Normally we expect a domain to clear pages before freeing them,
-             * if it cares about the secrecy of their contents. However, after
-             * a domain has died we assume responsibility for erasure.
-             */
-            scrub = !!d->is_dying;
         }
         else
         {
@@ -1882,12 +1873,10 @@ void free_domheap_pages(struct page_info *pg, unsigned int order)
              */
             ASSERT(!d || !order);
             drop_dom_ref = 0;
-            scrub = 1;
         }
 
-        if ( unlikely(scrub) )
-            for ( i = 0; i < (1 << order); i++ )
-                scrub_one_page(&pg[i]);
+        for ( i = 0; i < (1 << order); i++ )
+            scrub_one_page(&pg[i]);
 
         free_heap_pages(pg, order);
     }

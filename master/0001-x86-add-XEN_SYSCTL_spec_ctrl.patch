From 65b3f145b0383b55444dc3a95cd4d18ea5655fff Mon Sep 17 00:00:00 2001
From: Sergey Dyasli <sergey.dyasli@citrix.com>
Date: Tue, 26 Mar 2019 09:53:25 +0000
Subject: [PATCH 1/2] x86: add XEN_SYSCTL_spec_ctrl

stop_machine infrastructure is copied from live ucode update.
CPUID level 0x00000007:0.edx is updated on each cpu.
CPUID policies are recalculated if there are any CPUID changes.

Signed-off-by: Sergey Dyasli <sergey.dyasli@citrix.com>
diff --git a/xen/arch/x86/cpuid.c b/xen/arch/x86/cpuid.c
index baed5c2e5c..e463610f8f 100644
--- a/xen/arch/x86/cpuid.c
+++ b/xen/arch/x86/cpuid.c
@@ -8,10 +8,10 @@
 const uint32_t known_features[] = INIT_KNOWN_FEATURES;
 const uint32_t special_features[] = INIT_SPECIAL_FEATURES;
 
-static const uint32_t __initconst pv_featuremask[] = INIT_PV_FEATURES;
-static const uint32_t __initconst hvm_shadow_featuremask[] = INIT_HVM_SHADOW_FEATURES;
-static const uint32_t __initconst hvm_hap_featuremask[] = INIT_HVM_HAP_FEATURES;
-static const uint32_t __initconst deep_features[] = INIT_DEEP_FEATURES;
+static const uint32_t pv_featuremask[] = INIT_PV_FEATURES;
+static const uint32_t hvm_shadow_featuremask[] = INIT_HVM_SHADOW_FEATURES;
+static const uint32_t hvm_hap_featuremask[] = INIT_HVM_HAP_FEATURES;
+static const uint32_t deep_features[] = INIT_DEEP_FEATURES;
 
 uint32_t __read_mostly raw_featureset[FSCAPINTS];
 uint32_t __read_mostly pv_featureset[FSCAPINTS];
@@ -62,7 +62,7 @@ static int __init parse_xen_cpuid(const char *s)
 }
 custom_param("cpuid", parse_xen_cpuid);
 
-static void __init sanitise_featureset(uint32_t *fs)
+static void sanitise_featureset(uint32_t *fs)
 {
     /* for_each_set_bit() uses unsigned longs.  Extend with zeroes. */
     uint32_t disabled_features[
@@ -146,7 +146,7 @@ void calculate_raw_featureset(void)
               &tmp, &tmp);
 }
 
-static void __init guest_common_feature_adjustments(uint32_t *fs)
+static void guest_common_feature_adjustments(uint32_t *fs)
 {
     /* Unconditionally claim to be able to set the hypervisor bit. */
     __set_bit(X86_FEATURE_HYPERVISOR, fs);
@@ -168,7 +168,7 @@ static void __init guest_common_feature_adjustments(uint32_t *fs)
         __set_bit(X86_FEATURE_IBPB, fs);
 }
 
-static void __init calculate_pv_featureset(void)
+static void calculate_pv_featureset(void)
 {
     unsigned int i;
 
@@ -195,7 +195,7 @@ static void __init calculate_pv_featureset(void)
     sanitise_featureset(pv_featureset);
 }
 
-static void __init calculate_hvm_featureset(void)
+static void calculate_hvm_featureset(void)
 {
     unsigned int i;
     const uint32_t *hvm_featuremask;
@@ -257,19 +257,19 @@ static void __init calculate_hvm_featureset(void)
     sanitise_featureset(hvm_featureset);
 }
 
-void __init calculate_featuresets(void)
+void calculate_featuresets(void)
 {
     calculate_raw_featureset();
     calculate_pv_featureset();
     calculate_hvm_featureset();
 }
 
-const uint32_t * __init lookup_deep_deps(uint32_t feature)
+const uint32_t * lookup_deep_deps(uint32_t feature)
 {
     static const struct {
         uint32_t feature;
         uint32_t fs[FSCAPINTS];
-    } deep_deps[] __initconst = INIT_DEEP_DEPS;
+    } deep_deps[] = INIT_DEEP_DEPS;
     unsigned int start = 0, end = ARRAY_SIZE(deep_deps);
 
     BUILD_BUG_ON(ARRAY_SIZE(deep_deps) != NR_DEEP_DEPS);
diff --git a/xen/arch/x86/spec_ctrl.c b/xen/arch/x86/spec_ctrl.c
index fbac5ab904..d704ff604a 100644
--- a/xen/arch/x86/spec_ctrl.c
+++ b/xen/arch/x86/spec_ctrl.c
@@ -16,10 +16,15 @@
  *
  * Copyright (c) 2017-2018 Citrix Systems Ltd.
  */
+#include <xen/cpu.h>
 #include <xen/errno.h>
 #include <xen/init.h>
 #include <xen/lib.h>
+#include <xen/stop_machine.h>
 
+#include <public/platform.h>
+
+#include <asm/delay.h>
 #include <asm/domain.h>
 #include <asm/microcode.h>
 #include <asm/msr.h>
@@ -931,6 +936,164 @@ void __init init_speculation_mitigations(void)
     }
 }
 
+#define MICROCODE_CALLIN_TIMEOUT_US 30000
+#define MICROCODE_UPDATE_TIMEOUT_US 1000000
+
+static atomic_t cpu_in, cpu_out;
+static atomic_t next_cpu;
+
+static unsigned int common_caps;
+static uint32_t *spec_ctrl_status;
+
+/* Wait for CPUs to rendezvous with a timeout (us) */
+static int wait_for_cpus(atomic_t *cnt, unsigned int expect,
+                         unsigned int timeout)
+{
+    while ( atomic_read(cnt) < expect )
+    {
+        if ( timeout <= 0 )
+        {
+            printk("CPU%d: Timeout when waiting for CPUs calling in\n",
+                   smp_processor_id());
+            return -EBUSY;
+        }
+        udelay(1);
+        timeout--;
+    }
+
+    return 0;
+}
+
+static int update_x86_caps(void)
+{
+    int cpu = smp_processor_id();
+    struct cpuinfo_x86 *c = &cpu_data[cpu];
+    unsigned int edx, tmp;
+
+    if ( c->cpuid_level < 0x00000007 )
+        return -ENOSYS;
+
+    /* Intel-defined CPU features, CPUID level 0x00000007:0.edx, word 9 */
+    cpuid_count(0x00000007, 0, &tmp, &tmp, &tmp, &edx);
+    c->x86_capability[cpufeat_word(X86_FEATURE_IBRSB)] = edx;
+
+    /* Find the new common feature subset */
+    if ( common_caps == 0 )
+        common_caps = edx;
+    else
+        common_caps &= edx;
+
+    return 0;
+}
+
+static int recalc_cpuid_policy(void)
+{
+    unsigned int idx = cpufeat_word(X86_FEATURE_IBRSB);
+
+    if ( boot_cpu_data.x86_capability[idx] == common_caps )
+    {
+        /* No new H/W features have been detected */
+        *spec_ctrl_status = XENPF_spec_ctrl_noop;
+        return 0;
+    }
+
+    /* Update the global common feature set */
+    boot_cpu_data.x86_capability[idx] = common_caps;
+
+    /* Recalculate CPUID policies */
+    calculate_featuresets();
+
+    *spec_ctrl_status = XENPF_spec_ctrl_success;
+
+    return 0;
+}
+
+static int do_x86_caps_update(void *unused)
+{
+    int cpu = smp_processor_id();
+    unsigned int cpu_nr = num_online_cpus();
+    unsigned int finished;
+    int ret;
+    static bool error;
+
+    atomic_inc(&cpu_in);
+    ret = wait_for_cpus(&cpu_in, cpu_nr, MICROCODE_CALLIN_TIMEOUT_US);
+    if ( ret )
+        return ret;
+
+    while ( cpu != atomic_read(&next_cpu) )
+    {
+        finished = atomic_read(&cpu_out);
+        if ( wait_for_cpus(&next_cpu, cpu, MICROCODE_UPDATE_TIMEOUT_US) )
+        {
+            if ( atomic_read(&cpu_out) > finished )
+                continue;
+            printk("Timeout during do_x86_caps_update (finished %d/%d)",
+                   finished, cpu_nr);
+            return -EBUSY;
+        }
+    }
+
+    update_x86_caps();
+
+    finished = atomic_read(&cpu_out);
+    if ( finished == cpu_nr - 1 )
+    {
+        /* This is the last CPU. Update CPUID policy */
+        recalc_cpuid_policy();
+    }
+
+    atomic_set(&next_cpu, cpumask_next(cpu, &cpu_online_map));
+
+    atomic_inc(&cpu_out);
+    finished = atomic_read(&cpu_out);
+    while ( !error && finished != cpu_nr )
+    {
+        /*
+         * During each timeout interval, at least a CPU is expected to
+         * finish its update. Otherwise, something goes wrong.
+         */
+        if ( wait_for_cpus(&cpu_out, finished + 1,
+                           MICROCODE_UPDATE_TIMEOUT_US) && !error )
+        {
+            error = true;
+            printk("Timeout when finishing do_x86_caps_update (finished %d/%d)",
+                   finished, cpu_nr);
+            return -EBUSY;
+        }
+
+        finished = atomic_read(&cpu_out);
+    }
+
+    return 0;
+}
+
+int spec_ctrl_do_op(uint32_t op, uint32_t *status)
+{
+    int ret = 0;
+
+    if ( op != XENPF_spec_ctrl_update )
+        return -EINVAL;
+
+    if ( !get_cpu_maps() )
+        return -EBUSY;
+
+    *status = XENPF_spec_ctrl_error;
+    spec_ctrl_status = status;
+
+    atomic_set(&cpu_in, 0);
+    atomic_set(&cpu_out, 0);
+    atomic_set(&next_cpu, cpumask_first(&cpu_online_map));
+
+    common_caps = 0;
+
+    ret = stop_machine_run(do_x86_caps_update, NULL, NR_CPUS);
+
+    put_cpu_maps();
+
+    return ret;
+}
+
 static void __init __maybe_unused build_assertions(void)
 {
     /* The optimised assembly relies on this alias. */
diff --git a/xen/arch/x86/sysctl.c b/xen/arch/x86/sysctl.c
index b7a7e85ae7..723ff765c6 100644
--- a/xen/arch/x86/sysctl.c
+++ b/xen/arch/x86/sysctl.c
@@ -32,6 +32,7 @@
 #include <xsm/xsm.h>
 #include <asm/psr.h>
 #include <asm/cpuid.h>
+#include <asm/spec_ctrl.h>
 
 struct l3_cache_info {
     int ret;
@@ -262,6 +263,16 @@ long arch_do_sysctl(
         break;
     }
 
+    case XEN_SYSCTL_spec_ctrl:
+    {
+        ret = spec_ctrl_do_op(sysctl->u.spec_ctrl.op,
+                              &sysctl->u.spec_ctrl.status);
+        if ( ret == 0 )
+            ret = __copy_field_to_guest(u_sysctl, sysctl,
+                                        u.spec_ctrl) ? -EFAULT : 0;
+    }
+    break;
+
     default:
         ret = -ENOSYS;
         break;
diff --git a/xen/include/asm-x86/spec_ctrl.h b/xen/include/asm-x86/spec_ctrl.h
index ee7f18d52d..501c50b316 100644
--- a/xen/include/asm-x86/spec_ctrl.h
+++ b/xen/include/asm-x86/spec_ctrl.h
@@ -95,6 +95,8 @@ static always_inline void spec_ctrl_exit_idle(struct cpu_info *info)
                    : "memory" );
 }
 
+int spec_ctrl_do_op(uint32_t op, uint32_t *status);
+
 #endif /* !__X86_SPEC_CTRL_H__ */
 
 /*
diff --git a/xen/include/public/sysctl.h b/xen/include/public/sysctl.h
index a50c63bcf4..5a3fc05529 100644
--- a/xen/include/public/sysctl.h
+++ b/xen/include/public/sysctl.h
@@ -1032,6 +1032,18 @@ struct xen_sysctl_livepatch_op {
 typedef struct xen_sysctl_livepatch_op xen_sysctl_livepatch_op_t;
 DEFINE_XEN_GUEST_HANDLE(xen_sysctl_livepatch_op_t);
 
+struct xen_sysctl_spec_ctrl {
+#define XENPF_spec_ctrl_update  0 /* Try to use new mitigations */
+    uint32_t op;      /* IN */
+#define XENPF_spec_ctrl_success 0 /* New mitigations have been applied.       */
+                                  /* This is returned in case if some H/W     */
+                                  /* feature-bits have disappered! (Note that */
+                                  /* we don't expect this in practice.        */
+#define XENPF_spec_ctrl_noop    1 /* All mitigations are up to date */
+#define XENPF_spec_ctrl_error   2 /* Some error has occured */
+    uint32_t status;  /* OUT */
+};
+
 struct xen_sysctl {
     uint32_t cmd;
 #define XEN_SYSCTL_readconsole                    1
@@ -1060,6 +1072,7 @@ struct xen_sysctl {
 #define XEN_SYSCTL_get_cpu_levelling_caps        25
 #define XEN_SYSCTL_get_cpu_featureset            26
 #define XEN_SYSCTL_livepatch_op                  27
+#define XEN_SYSCTL_spec_ctrl                    188
     uint32_t interface_version; /* XEN_SYSCTL_INTERFACE_VERSION */
     union {
         struct xen_sysctl_readconsole       readconsole;
@@ -1088,6 +1101,7 @@ struct xen_sysctl {
         struct xen_sysctl_cpu_levelling_caps cpu_levelling_caps;
         struct xen_sysctl_cpu_featureset    cpu_featureset;
         struct xen_sysctl_livepatch_op      livepatch;
+        struct xen_sysctl_spec_ctrl         spec_ctrl;
         uint8_t                             pad[128];
     } u;
 };

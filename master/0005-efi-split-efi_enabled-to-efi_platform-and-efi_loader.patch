From 0b6e0d24660dc905b1524b1a2093dd1429552221 Mon Sep 17 00:00:00 2001
From: Daniel Kiper <daniel.kiper@oracle.com>
Date: Fri, 30 Jan 2015 18:54:09 +0100
Subject: [PATCH 05/18] efi: split efi_enabled to efi_platform and efi_loader

We need more fine grained knowledge about EFI environment and check
for EFI platform and EFI loader separately to properly support
multiboot2 protocol. In general Xen loaded by this protocol uses
memory mappings and loaded modules in simliar way to Xen loaded
by multiboot (v1) protocol. Hence, split efi_enabled to efi_platform
and efi_loader.

Signed-off-by: Daniel Kiper <daniel.kiper@oracle.com>
diff --git a/xen/arch/x86/dmi_scan.c b/xen/arch/x86/dmi_scan.c
index b049e31..bb50406 100644
--- a/xen/arch/x86/dmi_scan.c
+++ b/xen/arch/x86/dmi_scan.c
@@ -238,7 +238,7 @@ const char *__init dmi_get_table(paddr_t *base, u32 *len)
 {
 	static unsigned int __initdata instance;
 
-	if (efi_enabled) {
+	if (efi_platform) {
 		if (efi_smbios3_size && !(instance & 1)) {
 			*base = efi_smbios3_address;
 			*len = efi_smbios3_size;
@@ -696,7 +696,7 @@ static void __init dmi_decode(struct dmi_header *dm)
 
 void __init dmi_scan_machine(void)
 {
-	if ((!efi_enabled ? dmi_iterate(dmi_decode) :
+	if ((!efi_platform ? dmi_iterate(dmi_decode) :
 	                    dmi_efi_iterate(dmi_decode)) == 0)
  		dmi_check_system(dmi_blacklist);
 	else
diff --git a/xen/arch/x86/domain_page.c b/xen/arch/x86/domain_page.c
index 28f5a5c..4b11c4e 100644
--- a/xen/arch/x86/domain_page.c
+++ b/xen/arch/x86/domain_page.c
@@ -36,7 +36,7 @@ static inline struct vcpu *mapcache_current_vcpu(void)
      * domain's page tables but current may point at another domain's VCPU.
      * Return NULL as though current is not properly set up yet.
      */
-    if ( efi_enabled && efi_rs_using_pgtables() )
+    if ( efi_platform && efi_rs_using_pgtables() )
         return NULL;
 
     /*
diff --git a/xen/arch/x86/efi/stub.c b/xen/arch/x86/efi/stub.c
index 07c2bd0..51e0660 100644
--- a/xen/arch/x86/efi/stub.c
+++ b/xen/arch/x86/efi/stub.c
@@ -4,8 +4,9 @@
 #include <xen/lib.h>
 #include <asm/page.h>
 
-#ifndef efi_enabled
-const bool_t efi_enabled = 0;
+#ifndef efi_platform
+bool_t efi_platform = 0;
+bool_t efi_loader = 0;
 #endif
 
 void __init efi_init_memory(void) { }
diff --git a/xen/arch/x86/mpparse.c b/xen/arch/x86/mpparse.c
index 31e29d9..a754af3 100644
--- a/xen/arch/x86/mpparse.c
+++ b/xen/arch/x86/mpparse.c
@@ -571,7 +571,7 @@ static inline void __init construct_default_ISA_mptable(int mpc_default_type)
 
 static __init void efi_unmap_mpf(void)
 {
-	if (efi_enabled)
+	if (efi_platform)
 		clear_fixmap(FIX_EFI_MPF);
 }
 
@@ -729,7 +729,7 @@ void __init find_smp_config (void)
 {
 	unsigned int address;
 
-	if (efi_enabled) {
+	if (efi_platform) {
 		efi_check_config();
 		return;
 	}
diff --git a/xen/arch/x86/setup.c b/xen/arch/x86/setup.c
index 04b5db3..6a37e85 100644
--- a/xen/arch/x86/setup.c
+++ b/xen/arch/x86/setup.c
@@ -448,7 +448,7 @@ static void __init parse_video_info(void)
     struct boot_video_info *bvi = &bootsym(boot_vid_info);
 
     /* The EFI loader fills vga_console_info directly. */
-    if ( efi_enabled )
+    if ( efi_platform )
         return;
 
     if ( (bvi->orig_video_isVGA == 1) && (bvi->orig_video_mode == 3) )
@@ -735,7 +735,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
     if ( !(mbi->flags & MBI_MODULES) || (mbi->mods_count == 0) )
         panic("dom0 kernel not specified. Check bootloader configuration.");
 
-    if ( efi_enabled )
+    if ( efi_loader )
     {
         set_pdx_range(xen_phys_start >> PAGE_SHIFT,
                       (xen_phys_start + BOOTSTRAP_MAP_BASE) >> PAGE_SHIFT);
@@ -819,7 +819,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
     /* Sanitise the raw E820 map to produce a final clean version. */
     max_page = raw_max_page = init_e820(memmap_type, e820_raw, &e820_raw_nr);
 
-    if ( !efi_enabled )
+    if ( !efi_platform )
     {
         /*
          * Supplement the heuristics in l1tf_calculations() by assuming that
@@ -858,7 +858,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
      * we can relocate the dom0 kernel and other multiboot modules. Also, on
      * x86/64, we relocate Xen to higher memory.
      */
-    for ( i = 0; !efi_enabled && i < mbi->mods_count; i++ )
+    for ( i = 0; !efi_loader && i < mbi->mods_count; i++ )
     {
         if ( mod[i].mod_start & (PAGE_SIZE - 1) )
             panic("Bootloader didn't honor module alignment request.");
@@ -867,7 +867,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
         mod[i].reserved = 0;
     }
 
-    if ( efi_enabled )
+    if ( efi_loader )
     {
         /*
          * This needs to remain in sync with xen_in_range() and the
@@ -1060,7 +1060,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
 
             /* Don't overlap with other modules (or Xen itself). */
             end = consider_modules(s, e, size, mod,
-                                   mbi->mods_count + efi_enabled, j);
+                                   mbi->mods_count + efi_loader, j);
 
             if ( highmem_start && end > highmem_start )
                 continue;
@@ -1081,7 +1081,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
 #ifdef CONFIG_KEXEC
         /* Don't overlap with modules (or Xen itself). */
         e = consider_modules(s, e, PAGE_ALIGN(kexec_crash_area.size), mod,
-                             mbi->mods_count + efi_enabled, -1);
+                             mbi->mods_count + efi_loader, -1);
         if ( !kexec_crash_area.start && (s < e) )
         {
             e = (e - kexec_crash_area.size) & PAGE_MASK;
@@ -1103,7 +1103,7 @@ void __init noreturn __start_xen(unsigned long mbi_p)
         panic("Not enough memory to relocate Xen.");
 
     /* This needs to remain in sync with xen_in_range(). */
-    reserve_e820_ram(&boot_e820, efi_enabled ? mbi->mem_upper : __pa(_stext),
+    reserve_e820_ram(&boot_e820, efi_loader ? mbi->mem_upper : __pa(_stext),
                      __pa(__2M_rwdata_end));
 
     /* Late kexec reservation (dynamic start address). */
diff --git a/xen/arch/x86/shutdown.c b/xen/arch/x86/shutdown.c
index 0e1499d..985879d 100644
--- a/xen/arch/x86/shutdown.c
+++ b/xen/arch/x86/shutdown.c
@@ -116,9 +116,9 @@ void machine_halt(void)
 static void default_reboot_type(void)
 {
     if ( reboot_type == BOOT_INVALID )
-        reboot_type = efi_enabled ? BOOT_EFI
-                                  : acpi_disabled ? BOOT_KBD
-                                                  : BOOT_ACPI;
+        reboot_type = efi_platform ? BOOT_EFI
+                                   : acpi_disabled ? BOOT_KBD
+                                                   : BOOT_ACPI;
 }
 
 static int __init override_reboot(struct dmi_system_id *d)
diff --git a/xen/arch/x86/time.c b/xen/arch/x86/time.c
index d128c36..0e4282d 100644
--- a/xen/arch/x86/time.c
+++ b/xen/arch/x86/time.c
@@ -687,7 +687,7 @@ static unsigned long get_cmos_time(void)
     static bool_t __read_mostly cmos_rtc_probe;
     boolean_param("cmos-rtc-probe", cmos_rtc_probe);
 
-    if ( efi_enabled )
+    if ( efi_platform )
     {
         res = efi_get_time();
         if ( res )
diff --git a/xen/common/efi/boot.c b/xen/common/efi/boot.c
index d83635e..61abea9 100644
--- a/xen/common/efi/boot.c
+++ b/xen/common/efi/boot.c
@@ -934,6 +934,11 @@ efi_start(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
     char *option_str;
     bool_t use_cfg_file;
 
+#ifndef CONFIG_ARM /* TODO - disabled until implemented on ARM */
+    efi_platform = 1;
+    efi_loader = 1;
+#endif
+
     efi_init(ImageHandle, SystemTable);
 
     use_cfg_file = efi_arch_use_config_file(SystemTable);
diff --git a/xen/common/efi/runtime.c b/xen/common/efi/runtime.c
index f53101a..093c3e4 100644
--- a/xen/common/efi/runtime.c
+++ b/xen/common/efi/runtime.c
@@ -33,7 +33,8 @@ void efi_rs_leave(struct efi_rs_state *);
  * Currently runtime services are not implemented on ARM. To boot Xen with ACPI,
  * set efi_enabled to 1, so that Xen can get the ACPI root pointer from EFI.
  */
-const bool_t efi_enabled = 1;
+bool_t efi_platform = 0;
+bool_t efi_loader = 0;
 
 #ifndef CONFIG_ARM
 # include <asm/i387.h>
diff --git a/xen/drivers/acpi/osl.c b/xen/drivers/acpi/osl.c
index 9a49029..9a47271 100644
--- a/xen/drivers/acpi/osl.c
+++ b/xen/drivers/acpi/osl.c
@@ -66,7 +66,7 @@ void __init acpi_os_vprintf(const char *fmt, va_list args)
 
 acpi_physical_address __init acpi_os_get_root_pointer(void)
 {
-	if (efi_enabled) {
+	if (efi_platform) {
 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
 			return efi.acpi20;
 		else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
diff --git a/xen/include/xen/efi.h b/xen/include/xen/efi.h
index e74dad1..9d2c40f 100644
--- a/xen/include/xen/efi.h
+++ b/xen/include/xen/efi.h
@@ -5,7 +5,11 @@
 #include <xen/types.h>
 #endif
 
-extern const bool_t efi_enabled;
+/* If true then Xen runs on EFI platform. */
+extern bool_t efi_platform;
+
+/* If true then Xen was loaded by native EFI loader as PE application. */
+extern bool_t efi_loader;
 
 #define EFI_INVALID_TABLE_ADDR (~0UL)
 

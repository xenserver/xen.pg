From 7b20a865bc105fe566156201c8e6c37ef692e3dd Mon Sep 17 00:00:00 2001
From: Yang Qian <yang.qian@citrix.com>
Date: Mon, 8 Oct 2018 11:10:14 +0800
Subject: [PATCH] tools/ocaml: Release the global lock before invoking block
 syscalls

Functions related with event channel are parallelizable, so release global
lock before invoking C function which will finally call block syscalls.

Signed-off-by: Yang Qian <yang.qian@citrix.com>
Acked-by: Christian Lindig <christian.lindig@citrix.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
diff --git a/tools/ocaml/libs/eventchn/xeneventchn_stubs.c b/tools/ocaml/libs/eventchn/xeneventchn_stubs.c
index 2b7984f..ba40078 100644
--- a/tools/ocaml/libs/eventchn/xeneventchn_stubs.c
+++ b/tools/ocaml/libs/eventchn/xeneventchn_stubs.c
@@ -32,6 +32,7 @@
 #include <caml/custom.h>
 #include <caml/callback.h>
 #include <caml/fail.h>
+#include <caml/signals.h>
 
 #define _H(__h) ((xenevtchn_handle *)(__h))
 
@@ -39,8 +40,12 @@ CAMLprim value stub_eventchn_init(void)
 {
 	CAMLparam0();
 	CAMLlocal1(result);
+	xenevtchn_handle *xce;
+
+	caml_enter_blocking_section();
+	xce = xenevtchn_open(NULL, 0);
+	caml_leave_blocking_section();
 
-	xenevtchn_handle *xce = xenevtchn_open(NULL, 0);
 	if (xce == NULL)
 		caml_failwith("open failed");
 
@@ -68,7 +73,10 @@ CAMLprim value stub_eventchn_notify(value xce, value port)
 	CAMLparam2(xce, port);
 	int rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_notify(_H(xce), Int_val(port));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn notify failed");
 
@@ -82,7 +90,10 @@ CAMLprim value stub_eventchn_bind_interdomain(value xce, value domid,
 	CAMLlocal1(port);
 	xenevtchn_port_or_error_t rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_bind_interdomain(_H(xce), Int_val(domid), Int_val(remote_port));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn bind_interdomain failed");
 	port = Val_int(rc);
@@ -96,7 +107,10 @@ CAMLprim value stub_eventchn_bind_virq(value xce, value virq_type)
 	CAMLlocal1(port);
 	xenevtchn_port_or_error_t rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_bind_virq(_H(xce), Int_val(virq_type));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn bind_virq failed");
 	port = Val_int(rc);
@@ -109,7 +123,10 @@ CAMLprim value stub_eventchn_unbind(value xce, value port)
 	CAMLparam2(xce, port);
 	int rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_unbind(_H(xce), Int_val(port));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn unbind failed");
 
@@ -122,7 +139,10 @@ CAMLprim value stub_eventchn_pending(value xce)
 	CAMLlocal1(result);
 	xenevtchn_port_or_error_t port;
 
+	caml_enter_blocking_section();
 	port = xenevtchn_pending(_H(xce));
+	caml_leave_blocking_section();
+
 	if (port == -1)
 		caml_failwith("evtchn pending failed");
 	result = Val_int(port);
@@ -134,9 +154,15 @@ CAMLprim value stub_eventchn_unmask(value xce, value _port)
 {
 	CAMLparam2(xce, _port);
 	evtchn_port_t port;
+	int rc;
 
 	port = Int_val(_port);
-	if (xenevtchn_unmask(_H(xce), port))
+
+	caml_enter_blocking_section();
+	rc = xenevtchn_unmask(_H(xce), port);
+	caml_leave_blocking_section();
+
+	if (rc)
 		caml_failwith("evtchn unmask failed");
 	CAMLreturn(Val_unit);
 }

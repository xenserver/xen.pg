From 05697789020a0bec95b3edaccadf192f4d78544d Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Mon, 5 Feb 2018 14:50:10 +0000
Subject: [PATCH] x86/xpti: Introduce an ability to disable XPTI for dom0

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
diff --git a/xen/arch/x86/domain.c b/xen/arch/x86/domain.c
index 90d93d9de4..e49cac5080 100644
--- a/xen/arch/x86/domain.c
+++ b/xen/arch/x86/domain.c
@@ -701,6 +701,10 @@ int arch_domain_create(struct domain *d, unsigned int domcr_flags,
      */
     d->arch.x87_fip_width = cpu_has_fpu_sel ? 0 : 8;
 
+    if ( is_pv_domain(d) )
+        d->arch.pv_domain.xpti = opt_xpti &&
+                                 (opt_xpti_dom0 || d->domain_id != 0);
+
     return 0;
 
  fail:
diff --git a/xen/arch/x86/mm.c b/xen/arch/x86/mm.c
index 6bdc37d97c..ddf4267d82 100644
--- a/xen/arch/x86/mm.c
+++ b/xen/arch/x86/mm.c
@@ -4015,7 +4015,7 @@ long do_mmu_update(
                      * to the page lock we hold, its pinned status, and uses on
                      * this (v)CPU.
                      */
-                    if ( !rc && !!this_cpu(root_pgt) &&
+                    if ( !rc && pg_owner->arch.pv_domain.xpti &&
                          ((page->u.inuse.type_info & PGT_count_mask) >
                           (1 + !!(page->u.inuse.type_info & PGT_pinned) +
                            (pagetable_get_pfn(curr->arch.guest_table) == mfn) +
diff --git a/xen/arch/x86/smpboot.c b/xen/arch/x86/smpboot.c
index e7e0dbd91e..470aa68b89 100644
--- a/xen/arch/x86/smpboot.c
+++ b/xen/arch/x86/smpboot.c
@@ -747,8 +747,10 @@ static int clone_mapping(const void *ptr, root_pgentry_t *rpt)
     return 0;
 }
 
-static __read_mostly int8_t opt_xpti = -1;
+__read_mostly int8_t opt_xpti = -1;
 boolean_param("xpti", opt_xpti);
+__read_mostly bool opt_xpti_dom0 = true;
+boolean_param("xpti-dom0", opt_xpti_dom0);
 DEFINE_PER_CPU(root_pgentry_t *, root_pgt);
 
 static root_pgentry_t common_pgt;
diff --git a/xen/arch/x86/x86_64/asm-offsets.c b/xen/arch/x86/x86_64/asm-offsets.c
index 31ebbbeac8..d1e7ffd355 100644
--- a/xen/arch/x86/x86_64/asm-offsets.c
+++ b/xen/arch/x86/x86_64/asm-offsets.c
@@ -173,6 +173,7 @@ void __dummy__(void)
     BLANK();
 
     OFFSET(DOMAIN_is_32bit_pv, struct domain, arch.is_32bit_pv);
+    OFFSET(DOMAIN_arch_pv_xpti, struct domain, arch.pv_domain.xpti);
     BLANK();
 
     OFFSET(VMCB_rax, struct vmcb_struct, rax);
diff --git a/xen/arch/x86/x86_64/entry.S b/xen/arch/x86/x86_64/entry.S
index 4b00875745..3d74249086 100644
--- a/xen/arch/x86/x86_64/entry.S
+++ b/xen/arch/x86/x86_64/entry.S
@@ -42,6 +42,10 @@ restore_all_guest:
         /* Stash guest SPEC_CTRL value while we can read struct vcpu. */
         mov   VCPU_arch_spec_ctrl(%rbx), %r15d
 
+        mov VCPU_domain(%rbx), %rax
+        cmpb $0, DOMAIN_arch_pv_xpti(%rax)
+        je .Lrag_keep_cr3
+
         /* Copy guest mappings and switch to per-CPU root page table. */
         mov   %cr3, %r9
         GET_STACK_END(dx)
diff --git a/xen/include/asm-x86/domain.h b/xen/include/asm-x86/domain.h
index c3a867c5e8..d99b34cfa7 100644
--- a/xen/include/asm-x86/domain.h
+++ b/xen/include/asm-x86/domain.h
@@ -261,6 +261,8 @@ struct pv_domain
     struct mapcache_domain mapcache;
 
     struct cpuidmasks *cpuidmasks;
+
+    bool xpti;
 };
 
 struct monitor_write_data {
diff --git a/xen/include/asm-x86/smp.h b/xen/include/asm-x86/smp.h
index 33c2c32f42..af54cad1f6 100644
--- a/xen/include/asm-x86/smp.h
+++ b/xen/include/asm-x86/smp.h
@@ -72,6 +72,9 @@ void set_nr_sockets(void);
 /* Representing HT and core siblings in each socket. */
 extern cpumask_t **socket_cpumask;
 
+extern int8_t opt_xpti;
+extern bool opt_xpti_dom0;
+
 #endif /* !__ASSEMBLY__ */
 
 #endif

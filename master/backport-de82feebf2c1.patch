Author: Andrew Cooper <andrew.cooper3@citrix.com>
Date:   Mon Jan 26 14:30:43 2015 +0000

    xen/multicall: Rework arch multicall handling

    The x86 multicall handling was previously some very hairy inline assembly, and
    is hard to follow and maintain.

    Replace the existing do_multicall_call() with arch_do_multicall_call(). The
    x86 side needs to handle both compat and non-compat calls, so pass the full
    multicall state, rather than just the multicall_entry sub-structure.

    On the ARM side, alter the prototype to match, but there is no resulting
    functional change.  On the x86 side, the implementation is now in plain C.

    This allows the removal of both asm/multicall.h header files.

    Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
    Acked-by: Julien Grall <julien.grall@arm.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>

diff --git a/xen/arch/arm/traps.c b/xen/arch/arm/traps.c
index 8121d32..97994c2 100644
--- a/xen/arch/arm/traps.c
+++ b/xen/arch/arm/traps.c
@@ -1548,8 +1548,9 @@ static bool_t check_multicall_32bit_clean(struct multicall_entry *multi)
     return true;
 }
 
-enum mc_disposition do_multicall_call(struct multicall_entry *multi)
+enum mc_disposition arch_do_multicall_call(struct mc_state *state)
 {
+    struct multicall_entry *multi = &state->call;
     arm_hypercall_fn_t call = NULL;
 
     if ( multi->op >= ARRAY_SIZE(arm_hypercall_table) )
@@ -1574,7 +1575,7 @@ enum mc_disposition do_multicall_call(struct multicall_entry *multi)
                          multi->args[4]);
 
     return likely(!psr_mode_is_user(guest_cpu_user_regs()))
-           ? mc_continue : mc_preempt;
+        ? mc_continue : mc_preempt;
 }
 
 /*
diff --git a/xen/arch/x86/hypercall.c b/xen/arch/x86/hypercall.c
index faff260..c495b7a 100644
--- a/xen/arch/x86/hypercall.c
+++ b/xen/arch/x86/hypercall.c
@@ -340,6 +340,38 @@ void pv_hypercall(struct cpu_user_regs *regs)
     perfc_incr(hypercalls);
 }
 
+enum mc_disposition arch_do_multicall_call(struct mc_state *state)
+{
+    if ( !is_pv_32bit_vcpu(current) )
+    {
+        struct multicall_entry *call = &state->call;
+
+        if ( (call->op < NR_hypercalls) && hypercall_table[call->op] )
+            call->result = hypercall_table[call->op](
+                call->args[0], call->args[1], call->args[2],
+                call->args[3], call->args[4], call->args[5]);
+        else
+            call->result = -ENOSYS;
+
+        return multicall_ret(call);
+    }
+#ifdef CONFIG_COMPAT
+    else
+    {
+        struct compat_multicall_entry *call = &state->compat_call;
+
+        if ( (call->op < NR_hypercalls) && compat_hypercall_table[call->op] )
+            call->result = compat_hypercall_table[call->op](
+                call->args[0], call->args[1], call->args[2],
+                call->args[3], call->args[4], call->args[5]);
+        else
+            call->result = -ENOSYS;
+
+        return multicall_ret(call);
+    }
+#endif
+}
+
 /*
  * Local variables:
  * mode: C
diff --git a/xen/common/multicall.c b/xen/common/multicall.c
index 984aa92..5d25376 100644
--- a/xen/common/multicall.c
+++ b/xen/common/multicall.c
@@ -64,7 +64,7 @@ do_multicall(
 
         trace_multicall_call(&mcs->call);
 
-        disp = do_multicall_call(&mcs->call);
+        disp = arch_do_multicall_call(mcs);
 
 #ifndef NDEBUG
         {
diff --git a/xen/include/asm-arm/multicall.h b/xen/include/asm-arm/multicall.h
index ee3b345..5eb78fe 100644
--- a/xen/include/asm-arm/multicall.h
+++ b/xen/include/asm-arm/multicall.h
@@ -5,7 +5,7 @@ extern enum mc_disposition {
     mc_continue,
     mc_exit,
     mc_preempt,
-} do_multicall_call(struct multicall_entry *call);
+} arch_do_multicall_call(struct mc_state *state);
 
 #endif /* __ASM_ARM_MULTICALL_H__ */
 /*
diff --git a/xen/include/asm-x86/multicall.h b/xen/include/asm-x86/multicall.h
index 3cb0b6d..ddd8248 100644
--- a/xen/include/asm-x86/multicall.h
+++ b/xen/include/asm-x86/multicall.h
@@ -16,74 +16,10 @@ enum mc_disposition {
 #define multicall_ret(call)                                  \
     (unlikely((call)->op == __HYPERVISOR_iret)               \
      ? mc_exit                                               \
-       : likely(guest_kernel_mode(current,                   \
-                                  guest_cpu_user_regs()))    \
-         ? mc_continue : mc_preempt)
+     : likely(guest_kernel_mode(current,                     \
+                                guest_cpu_user_regs()))      \
+     ? mc_continue : mc_preempt)
 
-#define do_multicall_call(_call)                             \
-    ({                                                       \
-        __asm__ __volatile__ (                               \
-            "    movq  %c1(%0),%%rax; "                      \
-            "    leaq  hypercall_table(%%rip),%%rdi; "       \
-            "    cmpq  $("STR(NR_hypercalls)"),%%rax; "      \
-            "    jae   2f; "                                 \
-            "    movq  (%%rdi,%%rax,8),%%rax; "              \
-            "    movq  %c2+0*%c3(%0),%%rdi; "                \
-            "    movq  %c2+1*%c3(%0),%%rsi; "                \
-            "    movq  %c2+2*%c3(%0),%%rdx; "                \
-            "    movq  %c2+3*%c3(%0),%%rcx; "                \
-            "    movq  %c2+4*%c3(%0),%%r8; "                 \
-            "    movq  %c2+5*%c3(%0),%%r9; "                 \
-            "    callq *%%rax; "                             \
-            "1:  movq  %%rax,%c4(%0)\n"                      \
-            ".section .fixup,\"ax\"\n"                       \
-            "2:  movq  %5,%%rax\n"                           \
-            "    jmp   1b\n"                                 \
-            ".previous\n"                                    \
-            :                                                \
-            : "b" (_call),                                   \
-              "i" (offsetof(__typeof__(*_call), op)),        \
-              "i" (offsetof(__typeof__(*_call), args)),      \
-              "i" (sizeof(*(_call)->args)),                  \
-              "i" (offsetof(__typeof__(*_call), result)),    \
-              "i" (-ENOSYS)                                  \
-              /* all the caller-saves registers */           \
-            : "rax", "rcx", "rdx", "rsi", "rdi",             \
-              "r8",  "r9",  "r10", "r11" );                  \
-        multicall_ret(_call);                                \
-    })
-
-#define compat_multicall_call(_call)                         \
-    ({                                                       \
-        __asm__ __volatile__ (                               \
-            "    movl  %c1(%0),%%eax; "                      \
-            "    leaq  compat_hypercall_table(%%rip),%%rdi; "\
-            "    cmpl  $("STR(NR_hypercalls)"),%%eax; "      \
-            "    jae   2f; "                                 \
-            "    movq  (%%rdi,%%rax,8),%%rax; "              \
-            "    movl  %c2+0*%c3(%0),%%edi; "                \
-            "    movl  %c2+1*%c3(%0),%%esi; "                \
-            "    movl  %c2+2*%c3(%0),%%edx; "                \
-            "    movl  %c2+3*%c3(%0),%%ecx; "                \
-            "    movl  %c2+4*%c3(%0),%%r8d; "                \
-            "    movl  %c2+5*%c3(%0),%%r9d; "                \
-            "    callq *%%rax; "                             \
-            "1:  movl  %%eax,%c4(%0)\n"                      \
-            ".section .fixup,\"ax\"\n"                       \
-            "2:  movl  %5,%%eax\n"                           \
-            "    jmp   1b\n"                                 \
-            ".previous\n"                                    \
-            :                                                \
-            : "b" (_call),                                   \
-              "i" (offsetof(__typeof__(*_call), op)),        \
-              "i" (offsetof(__typeof__(*_call), args)),      \
-              "i" (sizeof(*(_call)->args)),                  \
-              "i" (offsetof(__typeof__(*_call), result)),    \
-              "i" (-ENOSYS)                                  \
-              /* all the caller-saves registers */           \
-            : "rax", "rcx", "rdx", "rsi", "rdi",             \
-              "r8",  "r9",  "r10", "r11" );                  \
-        multicall_ret(_call);                                \
-    })
+enum mc_disposition arch_do_multicall_call(struct mc_state *state);
 
 #endif /* __ASM_X86_MULTICALL_H__ */
diff --git a/xen/include/xen/multicall.h b/xen/include/xen/multicall.h
index 0e8d8bb..47230b3 100644
--- a/xen/include/xen/multicall.h
+++ b/xen/include/xen/multicall.h
@@ -6,7 +6,6 @@
 #define __XEN_MULTICALL_H__
 
 #include <xen/percpu.h>
-#include <asm/multicall.h>
 #ifdef CONFIG_COMPAT
 #include <compat/xen.h>
 #endif
@@ -25,4 +24,6 @@ struct mc_state {
     };
 };
 
+#include <asm/multicall.h>
+
 #endif /* __XEN_MULTICALL_H__ */

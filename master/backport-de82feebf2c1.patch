Author: Andrew Cooper <andrew.cooper3@citrix.com>
Date:   Mon Jan 26 14:30:43 2015 +0000

    xen/multicall: Rework arch multicall handling

    The x86 multicall handling was previously some very hairy inline assembly, and
    is hard to follow and maintain.

    Replace the existing do_multicall_call() with arch_do_multicall_call(). The
    x86 side needs to handle both compat and non-compat calls, so pass the full
    multicall state, rather than just the multicall_entry sub-structure.

    On the ARM side, alter the prototype to match, but there is no resulting
    functional change.  On the x86 side, the implementation is now in plain C.

    This allows the removal of both asm/multicall.h header files.

    Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
    Acked-by: Julien Grall <julien.grall@arm.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>

diff --git a/xen/arch/arm/traps.c b/xen/arch/arm/traps.c
index 512d0b7829..b76b0da5ca 100644
--- a/xen/arch/arm/traps.c
+++ b/xen/arch/arm/traps.c
@@ -1550,8 +1550,9 @@ static bool_t check_multicall_32bit_clean(struct multicall_entry *multi)
     return true;
 }
 
-enum mc_disposition do_multicall_call(struct multicall_entry *multi)
+enum mc_disposition arch_do_multicall_call(struct mc_state *state)
 {
+    struct multicall_entry *multi = &state->call;
     arm_hypercall_fn_t call = NULL;
 
     if ( multi->op >= ARRAY_SIZE(arm_hypercall_table) )
@@ -1576,7 +1577,7 @@ enum mc_disposition do_multicall_call(struct multicall_entry *multi)
                          multi->args[4]);
 
     return likely(!psr_mode_is_user(guest_cpu_user_regs()))
-           ? mc_continue : mc_preempt;
+        ? mc_continue : mc_preempt;
 }
 
 /*
diff --git a/xen/arch/x86/hypercall.c b/xen/arch/x86/hypercall.c
index faff2604c7..c495b7a815 100644
--- a/xen/arch/x86/hypercall.c
+++ b/xen/arch/x86/hypercall.c
@@ -340,6 +340,38 @@ void pv_hypercall(struct cpu_user_regs *regs)
     perfc_incr(hypercalls);
 }
 
+enum mc_disposition arch_do_multicall_call(struct mc_state *state)
+{
+    if ( !is_pv_32bit_vcpu(current) )
+    {
+        struct multicall_entry *call = &state->call;
+
+        if ( (call->op < NR_hypercalls) && hypercall_table[call->op] )
+            call->result = hypercall_table[call->op](
+                call->args[0], call->args[1], call->args[2],
+                call->args[3], call->args[4], call->args[5]);
+        else
+            call->result = -ENOSYS;
+
+        return multicall_ret(call);
+    }
+#ifdef CONFIG_COMPAT
+    else
+    {
+        struct compat_multicall_entry *call = &state->compat_call;
+
+        if ( (call->op < NR_hypercalls) && compat_hypercall_table[call->op] )
+            call->result = compat_hypercall_table[call->op](
+                call->args[0], call->args[1], call->args[2],
+                call->args[3], call->args[4], call->args[5]);
+        else
+            call->result = -ENOSYS;
+
+        return multicall_ret(call);
+    }
+#endif
+}
+
 /*
  * Local variables:
  * mode: C
diff --git a/xen/common/multicall.c b/xen/common/multicall.c
index 984aa92545..5d253761b2 100644
--- a/xen/common/multicall.c
+++ b/xen/common/multicall.c
@@ -64,7 +64,7 @@ do_multicall(
 
         trace_multicall_call(&mcs->call);
 
-        disp = do_multicall_call(&mcs->call);
+        disp = arch_do_multicall_call(mcs);
 
 #ifndef NDEBUG
         {
diff --git a/xen/include/asm-arm/multicall.h b/xen/include/asm-arm/multicall.h
index ee3b345903..5eb78fe504 100644
--- a/xen/include/asm-arm/multicall.h
+++ b/xen/include/asm-arm/multicall.h
@@ -5,7 +5,7 @@ extern enum mc_disposition {
     mc_continue,
     mc_exit,
     mc_preempt,
-} do_multicall_call(struct multicall_entry *call);
+} arch_do_multicall_call(struct mc_state *state);
 
 #endif /* __ASM_ARM_MULTICALL_H__ */
 /*
diff --git a/xen/include/asm-x86/multicall.h b/xen/include/asm-x86/multicall.h
index 415d7646b7..ddd824830d 100644
--- a/xen/include/asm-x86/multicall.h
+++ b/xen/include/asm-x86/multicall.h
@@ -16,74 +16,10 @@ enum mc_disposition {
 #define multicall_ret(call)                                  \
     (unlikely((call)->op == __HYPERVISOR_iret)               \
      ? mc_exit                                               \
-       : likely(guest_kernel_mode(current,                   \
-                                  guest_cpu_user_regs()))    \
-         ? mc_continue : mc_preempt)
+     : likely(guest_kernel_mode(current,                     \
+                                guest_cpu_user_regs()))      \
+     ? mc_continue : mc_preempt)
 
-#define do_multicall_call(_call)                             \
-    ({                                                       \
-        __asm__ __volatile__ (                               \
-            "    movq  %c1(%0),%%rax; "                      \
-            "    leaq  hypercall_table(%%rip),%%rdi; "       \
-            "    cmpq  $("STR(NR_hypercalls)"),%%rax; "      \
-            "    jae   2f; "                                 \
-            "    movq  (%%rdi,%%rax,8),%%rax; "              \
-            "    movq  %c2+0*%c3(%0),%%rdi; "                \
-            "    movq  %c2+1*%c3(%0),%%rsi; "                \
-            "    movq  %c2+2*%c3(%0),%%rdx; "                \
-            "    movq  %c2+3*%c3(%0),%%rcx; "                \
-            "    movq  %c2+4*%c3(%0),%%r8; "                 \
-            "    movq  %c2+5*%c3(%0),%%r9; "                 \
-            "    INDIRECT_CALL %%rax; "                      \
-            "1:  movq  %%rax,%c4(%0)\n"                      \
-            ".section .fixup,\"ax\"\n"                       \
-            "2:  movq  %5,%%rax\n"                           \
-            "    jmp   1b\n"                                 \
-            ".previous\n"                                    \
-            :                                                \
-            : "b" (_call),                                   \
-              "i" (offsetof(__typeof__(*_call), op)),        \
-              "i" (offsetof(__typeof__(*_call), args)),      \
-              "i" (sizeof(*(_call)->args)),                  \
-              "i" (offsetof(__typeof__(*_call), result)),    \
-              "i" (-ENOSYS)                                  \
-              /* all the caller-saves registers */           \
-            : "rax", "rcx", "rdx", "rsi", "rdi",             \
-              "r8",  "r9",  "r10", "r11" );                  \
-        multicall_ret(_call);                                \
-    })
-
-#define compat_multicall_call(_call)                         \
-    ({                                                       \
-        __asm__ __volatile__ (                               \
-            "    movl  %c1(%0),%%eax; "                      \
-            "    leaq  compat_hypercall_table(%%rip),%%rdi; "\
-            "    cmpl  $("STR(NR_hypercalls)"),%%eax; "      \
-            "    jae   2f; "                                 \
-            "    movq  (%%rdi,%%rax,8),%%rax; "              \
-            "    movl  %c2+0*%c3(%0),%%edi; "                \
-            "    movl  %c2+1*%c3(%0),%%esi; "                \
-            "    movl  %c2+2*%c3(%0),%%edx; "                \
-            "    movl  %c2+3*%c3(%0),%%ecx; "                \
-            "    movl  %c2+4*%c3(%0),%%r8d; "                \
-            "    movl  %c2+5*%c3(%0),%%r9d; "                \
-            "    INDIRECT_CALL %%rax; "                      \
-            "1:  movl  %%eax,%c4(%0)\n"                      \
-            ".section .fixup,\"ax\"\n"                       \
-            "2:  movl  %5,%%eax\n"                           \
-            "    jmp   1b\n"                                 \
-            ".previous\n"                                    \
-            :                                                \
-            : "b" (_call),                                   \
-              "i" (offsetof(__typeof__(*_call), op)),        \
-              "i" (offsetof(__typeof__(*_call), args)),      \
-              "i" (sizeof(*(_call)->args)),                  \
-              "i" (offsetof(__typeof__(*_call), result)),    \
-              "i" (-ENOSYS)                                  \
-              /* all the caller-saves registers */           \
-            : "rax", "rcx", "rdx", "rsi", "rdi",             \
-              "r8",  "r9",  "r10", "r11" );                  \
-        multicall_ret(_call);                                \
-    })
+enum mc_disposition arch_do_multicall_call(struct mc_state *state);
 
 #endif /* __ASM_X86_MULTICALL_H__ */
diff --git a/xen/include/xen/multicall.h b/xen/include/xen/multicall.h
index 0e8d8bb0ae..47230b3a01 100644
--- a/xen/include/xen/multicall.h
+++ b/xen/include/xen/multicall.h
@@ -6,7 +6,6 @@
 #define __XEN_MULTICALL_H__
 
 #include <xen/percpu.h>
-#include <asm/multicall.h>
 #ifdef CONFIG_COMPAT
 #include <compat/xen.h>
 #endif
@@ -25,4 +24,6 @@ struct mc_state {
     };
 };
 
+#include <asm/multicall.h>
+
 #endif /* __XEN_MULTICALL_H__ */

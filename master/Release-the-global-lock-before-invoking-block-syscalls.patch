From c42a8cce57e0c306f2ee854715dc8bf6b89bfddc Mon Sep 17 00:00:00 2001
From: Yang Qian <yang.qian@citrix.com>
Date: Wed, 26 Sep 2018 18:15:05 +0800
Subject: [PATCH] Release the global lock before invoking block syscalls

Functions related with event channel are parallelizable, so release global
lock before invoking C function which will finally call block syscalls.

Signed-off-by: Yang Qian <yang.qian@citrix.com>
---
 tools/ocaml/libs/eventchn/xeneventchn_stubs.c | 30 +++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/tools/ocaml/libs/eventchn/xeneventchn_stubs.c b/tools/ocaml/libs/eventchn/xeneventchn_stubs.c
index 2b7984f..ba40078 100644
--- a/tools/ocaml/libs/eventchn/xeneventchn_stubs.c
+++ b/tools/ocaml/libs/eventchn/xeneventchn_stubs.c
@@ -32,6 +32,7 @@
 #include <caml/custom.h>
 #include <caml/callback.h>
 #include <caml/fail.h>
+#include <caml/signals.h>
 
 #define _H(__h) ((xenevtchn_handle *)(__h))
 
@@ -39,8 +40,12 @@ CAMLprim value stub_eventchn_init(void)
 {
 	CAMLparam0();
 	CAMLlocal1(result);
+	xenevtchn_handle *xce;
+
+	caml_enter_blocking_section();
+	xce = xenevtchn_open(NULL, 0);
+	caml_leave_blocking_section();
 
-	xenevtchn_handle *xce = xenevtchn_open(NULL, 0);
 	if (xce == NULL)
 		caml_failwith("open failed");
 
@@ -68,7 +73,10 @@ CAMLprim value stub_eventchn_notify(value xce, value port)
 	CAMLparam2(xce, port);
 	int rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_notify(_H(xce), Int_val(port));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn notify failed");
 
@@ -82,7 +90,10 @@ CAMLprim value stub_eventchn_bind_interdomain(value xce, value domid,
 	CAMLlocal1(port);
 	xenevtchn_port_or_error_t rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_bind_interdomain(_H(xce), Int_val(domid), Int_val(remote_port));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn bind_interdomain failed");
 	port = Val_int(rc);
@@ -96,7 +107,10 @@ CAMLprim value stub_eventchn_bind_virq(value xce, value virq_type)
 	CAMLlocal1(port);
 	xenevtchn_port_or_error_t rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_bind_virq(_H(xce), Int_val(virq_type));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn bind_virq failed");
 	port = Val_int(rc);
@@ -109,7 +123,10 @@ CAMLprim value stub_eventchn_unbind(value xce, value port)
 	CAMLparam2(xce, port);
 	int rc;
 
+	caml_enter_blocking_section();
 	rc = xenevtchn_unbind(_H(xce), Int_val(port));
+	caml_leave_blocking_section();
+
 	if (rc == -1)
 		caml_failwith("evtchn unbind failed");
 
@@ -122,7 +139,10 @@ CAMLprim value stub_eventchn_pending(value xce)
 	CAMLlocal1(result);
 	xenevtchn_port_or_error_t port;
 
+	caml_enter_blocking_section();
 	port = xenevtchn_pending(_H(xce));
+	caml_leave_blocking_section();
+
 	if (port == -1)
 		caml_failwith("evtchn pending failed");
 	result = Val_int(port);
@@ -134,9 +154,15 @@ CAMLprim value stub_eventchn_unmask(value xce, value _port)
 {
 	CAMLparam2(xce, _port);
 	evtchn_port_t port;
+	int rc;
 
 	port = Int_val(_port);
-	if (xenevtchn_unmask(_H(xce), port))
+
+	caml_enter_blocking_section();
+	rc = xenevtchn_unmask(_H(xce), port);
+	caml_leave_blocking_section();
+
+	if (rc)
 		caml_failwith("evtchn unmask failed");
 	CAMLreturn(Val_unit);
 }
-- 
2.9.5


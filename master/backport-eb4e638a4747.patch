From eb4e638a474792137414f03409e78477810c3436 Mon Sep 17 00:00:00 2001
From: Jan Beulich <jbeulich@suse.com>
Date: Tue, 5 Sep 2017 17:32:43 +0200
Subject: [PATCH] x86emul: correct EVEX decoding

While these are latent issues only for now, correct them right away:
- unnamed (in the SDM) EVEX bits need to be set/clear respectively
- EVEX.V' (called RX in our code) needs to uniformly be 1 in non-64-bit
  modes,
- EXEX.R' (called R in our code) is uniformly being ignored in
  non-64-bit modes.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
diff --git a/xen/arch/x86/x86_emulate/x86_emulate.c b/xen/arch/x86/x86_emulate/x86_emulate.c
index 39bc4ea644..31791e31d9 100644
--- a/xen/arch/x86/x86_emulate/x86_emulate.c
+++ b/xen/arch/x86/x86_emulate/x86_emulate.c
@@ -311,13 +311,13 @@ union evex {
     uint8_t raw[3];
     struct {
         uint8_t opcx:2;
-        uint8_t :2;
+        uint8_t mbz:2;
         uint8_t R:1;
         uint8_t b:1;
         uint8_t x:1;
         uint8_t r:1;
         uint8_t pfx:2;
-        uint8_t evex:1;
+        uint8_t mbs:1;
         uint8_t reg:4;
         uint8_t w:1;
         uint8_t opmsk:3;
@@ -1791,6 +1791,14 @@ x86_emulate(
                         evex.raw[1] = vex.raw[1];
                         evex.raw[2] = insn_fetch_type(uint8_t);
 
+                        generate_exception_if(evex.mbs || !evex.mbz, EXC_UD, -1);
+
+                        if ( !mode_64bit() )
+                        {
+                            generate_exception_if(!evex.RX, EXC_UD, -1);
+                            evex.R = 1;
+                        }
+
                         vex.opcx = evex.opcx;
                     }
                 }

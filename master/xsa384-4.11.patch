From: Jan Beulich <jbeulich@suse.com>
Subject: gnttab: deal with status frame mapping race

Once gnttab_map_frame() drops the grant table lock, the MFN it reports
back to its caller is free to other manipulation. In particular
gnttab_unpopulate_status_frames() might free it, by a racing request on
another CPU, thus resulting in a reference to a deallocated page getting
added to a domain's P2M.

Obtain a page reference in gnttab_map_frame() to prevent freeing of the
page until xenmem_add_to_physmap_one() has actually completed its acting
on the page. Do so uniformly, even if only strictly required for v2
status pages, to avoid extra conditionals (which then would all need to
be kept in sync going forward).

This is CVE-2021-28701 / XSA-384.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Julien Grall <jgrall@amazon.com>

diff --git a/xen/arch/arm/mm.c b/xen/arch/arm/mm.c
index f4a6327..2fd07ba 100644
--- a/xen/arch/arm/mm.c
+++ b/xen/arch/arm/mm.c
@@ -1113,8 +1113,20 @@ int xenmem_add_to_physmap_one(
 
         if ( mfn != INVALID_MFN )
         {
-            gnttab_set_frame_gfn(d, status, idx, _gfn(gpfn));
+            /*
+             * Make sure gnttab_unpopulate_status_frames() won't (successfully)
+             * free the page until our caller has completed its operation.
+             */
+            if ( get_page(mfn_to_page(mfn), d) )
+                gnttab_set_frame_gfn(d, status, idx, _gfn(gpfn));
+            else
+            {
+                grant_write_unlock(d->grant_table);
+                return -EBUSY;
+            }
 
+            /* Need to take care of the reference obtained above. */
+            page = mfn_to_page(mfn);
             t = p2m_ram_rw;
         }
 
@@ -1187,9 +1199,12 @@ int xenmem_add_to_physmap_one(
     /* Map at new location. */
     rc = guest_physmap_add_entry(d, gpfn, mfn, 0, t);
 
-    /* If we fail to add the mapping, we need to drop the reference we
-     * took earlier on foreign pages */
-    if ( rc && space == XENMAPSPACE_gmfn_foreign )
+    /*
+     * For XENMAPSPACE_gmfn_foreign if we failed to add the mapping, we need
+     * to drop the reference we took earlier. In all other cases we need to
+     * drop any reference we took earlier (perhaps indirectly).
+     */
+    if ( space == XENMAPSPACE_gmfn_foreign ? rc : page != NULL )
     {
         ASSERT(page != NULL);
         put_page(page);
diff --git a/xen/arch/x86/mm.c b/xen/arch/x86/mm.c
index 461974a..79d58a6 100644
--- a/xen/arch/x86/mm.c
+++ b/xen/arch/x86/mm.c
@@ -5697,6 +5697,22 @@ int xenmem_add_to_physmap_one(
                     mfn = virt_to_mfn(d->grant_table->shared_raw[idx]);
             }
 
+            if ( mfn != 0 )
+            {
+                /*
+                 * Make sure gnttab_unpopulate_status_frames() won't (successfully)
+                 * free the page until our caller has completed its operation.
+                 */
+                if ( !get_page(mfn_to_page(mfn), d) )
+                {
+                    grant_write_unlock(d->grant_table);
+                    return -EBUSY;
+                }
+
+                /* Need to take care of the ref obtained above. */
+                page = mfn_to_page(mfn);
+            }
+
             grant_write_unlock(d->grant_table);
             break;
         case XENMAPSPACE_gmfn_range:

From 8d8db5a4ad267bca663bc1e41dccb53e072d73d2 Mon Sep 17 00:00:00 2001
From: Ian Jackson <ian.jackson@eu.citrix.com>
Date: Wed, 25 Sep 2019 16:14:21 +0200
Subject: tools/ocaml: abi check: Cope with consecutive relevant enums

If the end of one enum is the `type' line for the next enum, we would
not notice it.

Fix this by reordering the code, and getting rid of the else: now if
the "we are within an enum" branch decides that it's the end of the
enum, it unsets $ei and we then immediately process the line as a "not
within an enum" line - ie as the start of the next one.

Reported-by: Paul Durrant <paul.durrant@citrix.com>
Signed-off-by: Ian Jackson <ian.jackson@eu.citrix.com>
Signed-off-by: Paul Durrant <paul.durrant@citrix.com>
Acked-by: Christian Lindig <christian.lindig@citrix.com>

diff --git a/tools/ocaml/libs/xc/abi-check b/tools/ocaml/libs/xc/abi-check
index d532f37..3cbdec5 100755
--- a/tools/ocaml/libs/xc/abi-check
+++ b/tools/ocaml/libs/xc/abi-check
@@ -70,14 +70,7 @@ my $cval;
 $ei = undef;
 my $bitnum = 0;
 while (<OCAML_FILE>) {
-    if (!$ei) {
-        if (m{^type \s+ (\w+) \s* \= \s* $}x && $enums{$1}) {
-            print "// found ocaml type $1 at $o:$.\n" or die $!;
-            $ei = $enums{$1};
-            $cval = '';
-            $bitnum = 0;
-        }
-    } else {
+    if ($ei) {
         if (m{^\s+ \| \s* $ei->{OPrefix} (\w+) \s*$}x) {
             $cval = $1;
             if ($ei->{Mangle} eq 'lc') {
@@ -104,6 +97,14 @@ while (<OCAML_FILE>) {
             die "$_ ?";
         }
     }
+    if (!$ei) {
+        if (m{^type \s+ (\w+) \s* \= \s* $}x && $enums{$1}) {
+            print "// found ocaml type $1 at $o:$.\n" or die $!;
+            $ei = $enums{$1};
+            $cval = '';
+            $bitnum = 0;
+        }
+    }
 }
 
 foreach $ei (values %enums) {

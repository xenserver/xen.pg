From e30c8a11a9e84c1d19e7b24d54d2f6024cb0cac3 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Mon, 26 Jan 2015 15:11:59 +0000
Subject: [PATCH] x86/hypercall: Merge the hypercall arg tables

For the same reason as c/s 33a231e3f "x86/HVM: fold hypercall tables" and
c/s d6d67b047 "x86/pv: Merge the pv hypercall tables", this removes the
risk of accidentally updating only one of the tables.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
---
 xen/arch/x86/hvm/hvm.c          |  8 ++---
 xen/arch/x86/hypercall.c        | 70 +++++++++--------------------------------
 xen/include/asm-x86/hypercall.h |  7 +++--
 3 files changed, 24 insertions(+), 61 deletions(-)

diff --git a/xen/arch/x86/hvm/hvm.c b/xen/arch/x86/hvm/hvm.c
index cf2248f..23b0d17 100644
--- a/xen/arch/x86/hvm/hvm.c
+++ b/xen/arch/x86/hvm/hvm.c
@@ -4216,7 +4216,7 @@ int hvm_do_hypercall(struct cpu_user_regs *regs)
 
 #ifndef NDEBUG
         /* Deliberately corrupt parameter regs not used by this hypercall. */
-        switch ( hypercall_args_table[eax] )
+        switch ( hypercall_args_table[eax].native )
         {
         case 0: rdi = 0xdeadbeefdeadf00dUL;
         case 1: rsi = 0xdeadbeefdeadf00dUL;
@@ -4237,7 +4237,7 @@ int hvm_do_hypercall(struct cpu_user_regs *regs)
         if ( !curr->arch.hvm_vcpu.hcall_preempted )
         {
             /* Deliberately corrupt parameter regs used by this hypercall. */
-            switch ( hypercall_args_table[eax] )
+            switch ( hypercall_args_table[eax].native )
             {
             case 6: regs->r9  = 0xdeadbeefdeadf00dUL;
             case 5: regs->r8  = 0xdeadbeefdeadf00dUL;
@@ -4263,7 +4263,7 @@ int hvm_do_hypercall(struct cpu_user_regs *regs)
 
 #ifndef NDEBUG
         /* Deliberately corrupt parameter regs not used by this hypercall. */
-        switch ( compat_hypercall_args_table[eax] )
+        switch ( hypercall_args_table[eax].compat )
         {
         case 0: ebx = 0xdeadf00d;
         case 1: ecx = 0xdeadf00d;
@@ -4281,7 +4281,7 @@ int hvm_do_hypercall(struct cpu_user_regs *regs)
         if ( !curr->arch.hvm_vcpu.hcall_preempted )
         {
             /* Deliberately corrupt parameter regs used by this hypercall. */
-            switch ( compat_hypercall_args_table[eax] )
+            switch ( hypercall_args_table[eax].compat )
             {
             case 6: regs->ebp = 0xdeadf00d;
             case 5: regs->edi = 0xdeadf00d;
diff --git a/xen/arch/x86/hypercall.c b/xen/arch/x86/hypercall.c
index 4a96f23..41be870 100644
--- a/xen/arch/x86/hypercall.c
+++ b/xen/arch/x86/hypercall.c
@@ -22,77 +22,36 @@
 #include <xen/trace.h>
 
 #define ARGS(x, n)                              \
-    [ __HYPERVISOR_ ## x ] = (n)
+    [ __HYPERVISOR_ ## x ] = { n, n }
+#define COMP(x, n, c)                           \
+    [ __HYPERVISOR_ ## x ] = { n, c }
 
-const uint8_t hypercall_args_table[NR_hypercalls] =
+const hypercall_args_t hypercall_args_table[NR_hypercalls] =
 {
     ARGS(set_trap_table, 1),
     ARGS(mmu_update, 4),
     ARGS(set_gdt, 2),
     ARGS(stack_switch, 2),
-    ARGS(set_callbacks, 3),
+    COMP(set_callbacks, 3, 4),
     ARGS(fpu_taskswitch, 1),
     ARGS(sched_op_compat, 2),
     ARGS(platform_op, 1),
     ARGS(set_debugreg, 2),
     ARGS(get_debugreg, 1),
-    ARGS(update_descriptor, 2),
+    COMP(update_descriptor, 2, 4),
     ARGS(memory_op, 2),
     ARGS(multicall, 2),
-    ARGS(update_va_mapping, 3),
-    ARGS(set_timer_op, 1),
+    COMP(update_va_mapping, 3, 4),
+    COMP(set_timer_op, 1, 2),
     ARGS(event_channel_op_compat, 1),
     ARGS(xen_version, 2),
     ARGS(console_io, 3),
     ARGS(physdev_op_compat, 1),
     ARGS(grant_table_op, 3),
     ARGS(vm_assist, 2),
-    ARGS(update_va_mapping_otherdomain, 4),
-    ARGS(vcpu_op, 3),
-    ARGS(set_segment_base, 2),
-    ARGS(mmuext_op, 4),
-    ARGS(xsm_op, 1),
-    ARGS(nmi_op, 2),
-    ARGS(sched_op, 2),
-    ARGS(callback_op, 2),
-    ARGS(xenoprof_op, 2),
-    ARGS(event_channel_op, 2),
-    ARGS(physdev_op, 2),
-    ARGS(hvm_op, 2),
-    ARGS(sysctl, 1),
-    ARGS(domctl, 1),
-    ARGS(kexec_op, 2),
-    ARGS(tmem_op, 1),
-    ARGS(xenpmu_op, 2),
-    ARGS(mca, 1),
-    ARGS(arch_1, 1),
-};
-
-const uint8_t compat_hypercall_args_table[NR_hypercalls] =
-{
-    ARGS(set_trap_table, 1),
-    ARGS(mmu_update, 4),
-    ARGS(set_gdt, 2),
-    ARGS(stack_switch, 2),
-    ARGS(set_callbacks, 4),
-    ARGS(fpu_taskswitch, 1),
-    ARGS(sched_op_compat, 2),
-    ARGS(platform_op, 1),
-    ARGS(set_debugreg, 2),
-    ARGS(get_debugreg, 1),
-    ARGS(update_descriptor, 4),
-    ARGS(memory_op, 2),
-    ARGS(multicall, 2),
-    ARGS(update_va_mapping, 4),
-    ARGS(set_timer_op, 2),
-    ARGS(event_channel_op_compat, 1),
-    ARGS(xen_version, 2),
-    ARGS(console_io, 3),
-    ARGS(physdev_op_compat, 1),
-    ARGS(grant_table_op, 3),
-    ARGS(vm_assist, 2),
-    ARGS(update_va_mapping_otherdomain, 5),
+    COMP(update_va_mapping_otherdomain, 4, 5),
     ARGS(vcpu_op, 3),
+    COMP(set_segment_base, 2, 0),
     ARGS(mmuext_op, 4),
     ARGS(xsm_op, 1),
     ARGS(nmi_op, 2),
@@ -111,6 +70,7 @@ const uint8_t compat_hypercall_args_table[NR_hypercalls] =
     ARGS(arch_1, 1),
 };
 
+#undef COMP
 #undef ARGS
 
 #define HYPERCALL(x)                                                \
@@ -205,7 +165,7 @@ void pv_hypercall(struct cpu_user_regs *regs)
 
 #ifndef NDEBUG
         /* Deliberately corrupt parameter regs not used by this hypercall. */
-        switch ( hypercall_args_table[eax] )
+        switch ( hypercall_args_table[eax].native )
         {
         case 0: rdi = 0xdeadbeefdeadf00dUL;
         case 1: rsi = 0xdeadbeefdeadf00dUL;
@@ -228,7 +188,7 @@ void pv_hypercall(struct cpu_user_regs *regs)
         if ( regs->rip == old_rip )
         {
             /* Deliberately corrupt parameter regs used by this hypercall. */
-            switch ( hypercall_args_table[eax] )
+            switch ( hypercall_args_table[eax].native )
             {
             case 6: regs->r9  = 0xdeadbeefdeadf00dUL;
             case 5: regs->r8  = 0xdeadbeefdeadf00dUL;
@@ -251,7 +211,7 @@ void pv_hypercall(struct cpu_user_regs *regs)
 
 #ifndef NDEBUG
         /* Deliberately corrupt parameter regs not used by this hypercall. */
-        switch ( compat_hypercall_args_table[eax] )
+        switch ( hypercall_args_table[eax].compat )
         {
         case 0: ebx = 0xdeadf00d;
         case 1: ecx = 0xdeadf00d;
@@ -275,7 +235,7 @@ void pv_hypercall(struct cpu_user_regs *regs)
         if ( regs->rip == old_rip )
         {
             /* Deliberately corrupt parameter regs used by this hypercall. */
-            switch ( compat_hypercall_args_table[eax] )
+            switch ( hypercall_args_table[eax].compat )
             {
             case 6: regs->_ebp = 0xdeadf00d;
             case 5: regs->_edi = 0xdeadf00d;
diff --git a/xen/include/asm-x86/hypercall.h b/xen/include/asm-x86/hypercall.h
index c00de2b..c59aa69 100644
--- a/xen/include/asm-x86/hypercall.h
+++ b/xen/include/asm-x86/hypercall.h
@@ -19,8 +19,11 @@ typedef struct {
     hypercall_fn_t *native, *compat;
 } hypercall_table_t;
 
-extern const uint8_t hypercall_args_table[NR_hypercalls],
-  compat_hypercall_args_table[NR_hypercalls];
+typedef struct {
+    uint8_t native, compat;
+} hypercall_args_t;
+
+extern const hypercall_args_t hypercall_args_table[NR_hypercalls];
 
 /*
  * Both do_mmuext_op() and do_mmu_update():
-- 
2.7.4


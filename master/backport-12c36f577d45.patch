From 12c36f577d454996c882ecdc5da8113ca2613646 Mon Sep 17 00:00:00 2001
From: Igor Druzhinin <igor.druzhinin@citrix.com>
Date: Tue, 12 Mar 2019 14:38:12 +0100
Subject: [PATCH] iommu: leave IOMMU enabled by default during kexec crash
 transition

It's unsafe to disable IOMMU on a live system which is the case
if we're crashing since remapping hardware doesn't usually know what
to do with ongoing bus transactions and frequently raises NMI/MCE/SMI,
etc. (depends on the firmware configuration) to signal these abnormalities.
This, in turn, doesn't play well with kexec transition process as there is
no handling available at the moment for this kind of events resulting
in failures to enter the kernel.

Modern Linux kernels taught to copy all the necessary DMAR/IR tables
following kexec from the previous kernel (Xen in our case) - so it's
currently normal to keep IOMMU enabled. It might require minor changes to
kdump command line that enables IOMMU drivers (e.g. intel_iommu=on /
intremap=on) but recent kernels don't require any additional changes for
the transition to be transparent.

A fallback option is still left for compatibility with ancient crash
kernels which didn't like to have IOMMU active under their feet on boot.

Signed-off-by: Igor Druzhinin <igor.druzhinin@citrix.com>
Acked-by: Jan Beulich <jbeulich@suse.com>
diff --git a/xen/arch/x86/crash.c b/xen/arch/x86/crash.c
index 8d74258..c9e483a 100644
--- a/xen/arch/x86/crash.c
+++ b/xen/arch/x86/crash.c
@@ -165,8 +165,11 @@ static void nmi_shootdown_cpus(void)
         printk("Failed to shoot down CPUs {%s}\n", keyhandler_scratch);
     }
 
-    /* Crash shutdown any IOMMU functionality as the crashdump kernel is not
-     * happy when booting if interrupt/dma remapping is still enabled */
+    /*
+     * Try to crash shutdown IOMMU functionality as some old crashdump
+     * kernels are not happy when booting if interrupt/dma remapping
+     * is still enabled.
+     */
     iommu_crash_shutdown();
 
     __stop_this_cpu();
diff --git a/xen/drivers/passthrough/iommu.c b/xen/drivers/passthrough/iommu.c
index 106f73b..6d791a8 100644
--- a/xen/drivers/passthrough/iommu.c
+++ b/xen/drivers/passthrough/iommu.c
@@ -60,6 +60,7 @@ bool_t __read_mostly iommu_passthrough;
 bool_t __read_mostly iommu_snoop = 1;
 bool_t __read_mostly iommu_qinval = 1;
 bool_t __read_mostly iommu_intremap = 1;
+bool_t __read_mostly iommu_crash_disable;
 
 /*
  * In the current implementation of VT-d posted interrupts, in some extreme
@@ -112,6 +113,10 @@ static int __init parse_iommu_param(const char *s)
             iommu_intremap = val;
         else if ( !cmdline_strcmp(s, "intpost") )
             iommu_intpost = val;
+#ifdef CONFIG_KEXEC
+        else if ( !cmdline_strcmp(s, "crash-disable") )
+            iommu_crash_disable = val;
+#endif
         else if ( !cmdline_strcmp(s, "debug") )
         {
             iommu_debug = val;
@@ -532,6 +537,9 @@ void iommu_share_p2m_table(struct domain* d)
 
 void iommu_crash_shutdown(void)
 {
+    if ( !iommu_crash_disable )
+        return;
+
     if ( iommu_enabled )
         iommu_get_ops()->crash_shutdown();
     iommu_enabled = iommu_intremap = iommu_intpost = 0;

From: Xen Project Security Team <security@xenproject.org>
Subject: x86/vHPET: check that the set interrupt route is valid

The value written by the guest must be valid according to the mask
provided in the interrupt routing capabilities register. If the
interrupt is not valid set it to the first valid IRQ in the
capabilities field if the timer is enabled, else just clear the field.

Also refuse to start any timer that has an invalid interrupt route.

This is part of XSA-261.

Reviewed-by: Jan Beulich <jbeulich@suse.com>
---
Changes since v2:
 - If the timer is not enabled just clear the interrupt field if it's
   not valid.

Changes since v1:
 - Pick the first valid IRQ instead of zeroing the field when an
   invalid value is written.
 - Replace ul usage in timer_int_valid with u.

--- a/xen/arch/x86/hvm/hpet.c
+++ b/xen/arch/x86/hvm/hpet.c
@@ -73,6 +73,9 @@
     ((timer_config(h, n) & HPET_TN_INT_ROUTE_CAP_MASK) \
         >> HPET_TN_INT_ROUTE_CAP_SHIFT)
 
+#define timer_int_valid(h, n) \
+    ((1u << timer_int_route(h, n)) & timer_int_route_cap(h, n))
+
 static inline uint64_t hpet_read_maincounter(HPETState *h, uint64_t guest_time)
 {
     ASSERT(rw_is_locked(&h->lock));
@@ -241,6 +244,12 @@ static void hpet_set_timer(HPETState *h,
         pit_stop_channel0_irq(&vhpet_domain(h)->arch.vpit);
     }
 
+    if ( !timer_int_valid(h, tn) )
+    {
+        ASSERT_UNREACHABLE();
+        return;
+    }
+
     if ( !timer_enabled(h, tn) )
         return;
 
@@ -386,6 +395,26 @@ static int hpet_write(
 
         h->hpet.timers[tn].config = hpet_fixup_reg(new_val, old_val, 0x3f4e);
 
+        if ( !timer_int_valid(h, tn) )
+        {
+            h->hpet.timers[tn].config &= ~HPET_TN_ROUTE;
+            if ( timer_enabled(h, tn) )
+            {
+                /*
+                 * If the requested interrupt is not valid and the timer is
+                 * enabled pick the first irq.
+                 */
+                unsigned int irq = ffs(timer_int_route_cap(h, tn));
+
+                if ( !irq )
+                {
+                    ASSERT_UNREACHABLE();
+                    break;
+                }
+                h->hpet.timers[tn].config |= (irq - 1) << HPET_TN_ROUTE_SHIFT;
+            }
+        }
+
         if ( timer_level(h, tn) )
         {
             gdprintk(XENLOG_ERR,

From 92d16c30d15388f63c05326f2eb2c10a1a0e2c8d Mon Sep 17 00:00:00 2001
From: Sergey Dyasli <sergey.dyasli@citrix.com>
Date: Wed, 13 Mar 2019 15:40:24 +0000
Subject: [PATCH 4/8] microcode: add sequential application policy

This patch was sent upstream to Chao. I expect it to be included in v7.

Signed-off-by: Sergey Dyasli <sergey.dyasli@citrix.com>
diff --git a/tools/libxc/include/xenctrl.h b/tools/libxc/include/xenctrl.h
index 5b912f6bfc..50d68ebc62 100644
--- a/tools/libxc/include/xenctrl.h
+++ b/tools/libxc/include/xenctrl.h
@@ -1263,7 +1263,8 @@ int xc_physinfo(xc_interface *xch, xc_physinfo_t *info);
 int xc_cputopoinfo(xc_interface *xch, unsigned *max_cpus,
                    xc_cputopo_t *cputopo);
 int xc_platform_op(xc_interface *xch, struct xen_platform_op *op);
-int xc_microcode_update(xc_interface *xch, const void *buf, size_t len);
+int xc_microcode_update(xc_interface *xch, const void *buf, size_t len,
+                        uint32_t strategy);
 int xc_numainfo(xc_interface *xch, unsigned *max_nodes,
                 xc_meminfo_t *meminfo, uint32_t *distance);
 int xc_pcitopoinfo(xc_interface *xch, unsigned num_devs,
diff --git a/tools/libxc/xc_misc.c b/tools/libxc/xc_misc.c
index 89437b9d42..9e9eabfb0d 100644
--- a/tools/libxc/xc_misc.c
+++ b/tools/libxc/xc_misc.c
@@ -226,7 +226,8 @@ int xc_physinfo(xc_interface *xch,
     return 0;
 }
 
-int xc_microcode_update(xc_interface *xch, const void *buf, size_t len)
+int xc_microcode_update(xc_interface *xch, const void *buf, size_t len,
+                        uint32_t strategy)
 {
     int ret;
     DECLARE_PLATFORM_OP;
@@ -240,6 +241,7 @@ int xc_microcode_update(xc_interface *xch, const void *buf, size_t len)
 
     platform_op.cmd = XENPF_microcode_update;
     platform_op.u.microcode.length = len;
+    platform_op.u.microcode.strategy = strategy;
     set_xen_guest_handle(platform_op.u.microcode.data, uc);
 
     ret = do_platform_op(xch, &platform_op);
diff --git a/tools/misc/xen-ucode.c b/tools/misc/xen-ucode.c
index 2f8306fe29..28c652e6c1 100644
--- a/tools/misc/xen-ucode.c
+++ b/tools/misc/xen-ucode.c
@@ -62,7 +62,7 @@ void show_help(void)
 {
     fprintf(stderr,
             "xen-ucode: Xen microcode updating tool\n"
-            "Usage: xen-ucode <microcode blob>\n");
+            "Usage: xen-ucode <microcode blob> <parallel|sequential>\n");
 
     show_curr_cpu(stderr);
 }
@@ -73,6 +73,7 @@ int main(int argc, char *argv[])
     char *filename, *buf;
     struct stat st;
     xc_interface *xch;
+    uint32_t strategy;
 
     if ( argc >= 2 && !strcmp(argv[1], "show-cpu-info") )
     {
@@ -80,7 +81,17 @@ int main(int argc, char *argv[])
         return 0;
     }
 
-    if (argc < 2)
+    if (argc < 3)
+    {
+        show_help();
+        return 0;
+    }
+
+    if (!strcmp(argv[2], "parallel"))
+        strategy = XENPF_microcode_parallel;
+    else if (!strcmp(argv[2], "sequential"))
+        strategy = XENPF_microcode_sequential;
+    else
     {
         show_help();
         return 0;
@@ -115,7 +126,7 @@ int main(int argc, char *argv[])
         return errno;
     }
 
-    ret = xc_microcode_update(xch, buf, len);
+    ret = xc_microcode_update(xch, buf, len, strategy);
     if (ret)
         fprintf(stderr, "Failed to update microcode. (err: %s)\n",
                 strerror(errno));
diff --git a/xen/arch/x86/microcode.c b/xen/arch/x86/microcode.c
index 8aeb152317..fad8054384 100644
--- a/xen/arch/x86/microcode.c
+++ b/xen/arch/x86/microcode.c
@@ -37,6 +37,8 @@
 #include <xen/earlycpio.h>
 #include <xen/watchdog.h>
 
+#include <public/platform.h>
+
 #include <asm/delay.h>
 #include <asm/msr.h>
 #include <asm/processor.h>
@@ -215,6 +217,10 @@ DEFINE_PER_CPU(struct cpu_signature, cpu_sig);
  */
 static atomic_t cpu_in, cpu_out, cpu_updated;
 
+static uint32_t application_strategy;
+/* The next CPU to perform a ucode update */
+static atomic_t next_cpu;
+
 /*
  * Return the patch with the highest revision id among all matching
  * patches in the blob. Return NULL if no suitable patch.
@@ -328,6 +334,19 @@ static int do_microcode_update(void *patch)
     if ( ret )
         return ret;
 
+    while ( application_strategy == XENPF_microcode_sequential &&
+            cpu != atomic_read(&next_cpu) )
+    {
+        finished = atomic_read(&cpu_out);
+        if ( wait_for_cpus(&next_cpu, cpu, MICROCODE_UPDATE_TIMEOUT_US) )
+        {
+            if ( atomic_read(&cpu_out) > finished )
+                continue;
+            panic("Timeout during sequential microcode update (finished %d/%d)",
+                  finished, cpu_nr);
+        }
+    }
+
     ret = microcode_ops->collect_cpu_info(&this_cpu(cpu_sig));
     /*
      * Load microcode update on only one logical processor per core.
@@ -340,6 +359,10 @@ static int do_microcode_update(void *patch)
         if ( !ret )
             atomic_inc(&cpu_updated);
     }
+
+    if ( application_strategy == XENPF_microcode_sequential )
+        atomic_set(&next_cpu, cpumask_next(cpu, &cpu_online_map));
+
     /*
      * Increase the wait timeout to a safe value here since we're serializing
      * the microcode update and that could take a while on a large number of
@@ -375,7 +398,8 @@ static int do_microcode_update(void *patch)
     return ret;
 }
 
-int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len)
+int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len,
+                     uint32_t strategy)
 {
     int ret;
     void *buffer;
@@ -388,6 +412,10 @@ int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len)
     if ( microcode_ops == NULL )
         return -EINVAL;
 
+    if ( strategy != XENPF_microcode_parallel &&
+         strategy != XENPF_microcode_sequential )
+        return -EINVAL;
+
     buffer = xmalloc_bytes(len);
     if ( !buffer )
     {
@@ -442,13 +470,19 @@ int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len)
         if ( cpu == cpumask_first(per_cpu(cpu_sibling_mask, cpu)) )
             nr_cores++;
 
-    printk(XENLOG_INFO "%d cores are to update their microcode\n", nr_cores);
+    printk(XENLOG_INFO "%d cores are to update their microcode %s\n", nr_cores,
+           strategy == XENPF_microcode_parallel ? "in parallel" :
+                                                  "sequentially");
 
     /*
      * We intend to disable interrupt for long time, which may lead to
      * watchdog timeout.
      */
     watchdog_disable();
+
+    application_strategy = strategy;
+    if ( strategy == XENPF_microcode_sequential )
+        atomic_set(&next_cpu, cpumask_first(&cpu_online_map));
     /*
      * Late loading dance. Why the heavy-handed stop_machine effort?
      *
diff --git a/xen/arch/x86/platform_hypercall.c b/xen/arch/x86/platform_hypercall.c
index 4d7398ef63..7f7818f6bf 100644
--- a/xen/arch/x86/platform_hypercall.c
+++ b/xen/arch/x86/platform_hypercall.c
@@ -297,7 +297,8 @@ ret_t do_platform_op(XEN_GUEST_HANDLE_PARAM(xen_platform_op_t) u_xenpf_op)
 
         ret = microcode_update(
                 guest_handle_to_param(data, const_void),
-                op->u.microcode.length);
+                op->u.microcode.length,
+                op->u.microcode.strategy);
         spin_unlock(&vcpu_alloc_lock);
     }
     break;
diff --git a/xen/include/asm-x86/processor.h b/xen/include/asm-x86/processor.h
index 0a62dfa0a3..612b786e81 100644
--- a/xen/include/asm-x86/processor.h
+++ b/xen/include/asm-x86/processor.h
@@ -573,7 +573,8 @@ int rdmsr_hypervisor_regs(uint32_t idx, uint64_t *val);
 int wrmsr_hypervisor_regs(uint32_t idx, uint64_t val);
 
 void microcode_set_module(unsigned int);
-int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void), unsigned long len);
+int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void), unsigned long len,
+                     uint32_t strategy);
 int early_microcode_update_cpu(void);
 int early_microcode_init(void);
 int microcode_init_intel(void);
diff --git a/xen/include/public/platform.h b/xen/include/public/platform.h
index e858872ca5..07e3cf1bb8 100644
--- a/xen/include/public/platform.h
+++ b/xen/include/public/platform.h
@@ -114,6 +114,9 @@ struct xenpf_microcode_update {
     /* IN variables. */
     XEN_GUEST_HANDLE(const_void) data;/* Pointer to microcode data */
     uint32_t length;                  /* Length of microcode data. */
+#define XENPF_microcode_parallel   0
+#define XENPF_microcode_sequential 1
+    uint32_t strategy;                /* Application strategy.     */
 };
 typedef struct xenpf_microcode_update xenpf_microcode_update_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_microcode_update_t);

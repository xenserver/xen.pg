From 92d16c30d15388f63c05326f2eb2c10a1a0e2c8d Mon Sep 17 00:00:00 2001
From: Sergey Dyasli <sergey.dyasli@citrix.com>
Date: Wed, 13 Mar 2019 15:40:24 +0000
Subject: [PATCH 4/8] microcode: add sequential application policy

This patch was sent upstream to Chao. I expect it to be included in v7.

Signed-off-by: Sergey Dyasli <sergey.dyasli@citrix.com>
diff --git a/tools/libxc/include/xenctrl.h b/tools/libxc/include/xenctrl.h
index 68c89eadd6..a4fe860e5c 100644
--- a/tools/libxc/include/xenctrl.h
+++ b/tools/libxc/include/xenctrl.h
@@ -1246,7 +1246,8 @@ int xc_physinfo(xc_interface *xch, xc_physinfo_t *info);
 int xc_cputopoinfo(xc_interface *xch, unsigned *max_cpus,
                    xc_cputopo_t *cputopo);
 int xc_platform_op(xc_interface *xch, struct xen_platform_op *op);
-int xc_microcode_update(xc_interface *xch, const void *buf, size_t len);
+int xc_microcode_update(xc_interface *xch, const void *buf, size_t len,
+                        uint32_t strategy);
 int xc_numainfo(xc_interface *xch, unsigned *max_nodes,
                 xc_meminfo_t *meminfo, uint32_t *distance);
 int xc_pcitopoinfo(xc_interface *xch, unsigned num_devs,
diff --git a/tools/libxc/xc_misc.c b/tools/libxc/xc_misc.c
index 9f047ba184..3cc87e20eb 100644
--- a/tools/libxc/xc_misc.c
+++ b/tools/libxc/xc_misc.c
@@ -226,7 +226,8 @@ int xc_physinfo(xc_interface *xch,
     return 0;
 }
 
-int xc_microcode_update(xc_interface *xch, const void *buf, size_t len)
+int xc_microcode_update(xc_interface *xch, const void *buf, size_t len,
+                        uint32_t strategy)
 {
     int ret;
     DECLARE_PLATFORM_OP;
@@ -240,6 +241,7 @@ int xc_microcode_update(xc_interface *xch, const void *buf, size_t len)
 
     platform_op.cmd = XENPF_microcode_update;
     platform_op.u.microcode.length = len;
+    platform_op.u.microcode.strategy = strategy;
     set_xen_guest_handle(platform_op.u.microcode.data, uc);
 
     ret = do_platform_op(xch, &platform_op);
diff --git a/tools/misc/xen-ucode.c b/tools/misc/xen-ucode.c
index e12af01bf2..4f861abd53 100644
--- a/tools/misc/xen-ucode.c
+++ b/tools/misc/xen-ucode.c
@@ -58,6 +58,15 @@ void show_curr_cpu(FILE *f)
     xc_interface_close(xch);
 }
 
+static int parse_strategy(const char *arg)
+{
+    if ( !strcmp(arg, "parallel") )
+        return XENPF_microcode_parallel;
+    if ( !strcmp(arg, "sequential") )
+        return XENPF_microcode_sequential;
+    return -1;
+}
+
 int main(int argc, char *argv[])
 {
     int fd, ret;
@@ -65,6 +74,7 @@ int main(int argc, char *argv[])
     size_t len;
     struct stat st;
     xc_interface *xch;
+    int strategy;
 
     if ( argc >= 2 && !strcmp(argv[1], "show-cpu-info") )
     {
@@ -72,11 +82,11 @@ int main(int argc, char *argv[])
         return 0;
     }
 
-    if ( argc < 2 )
+    if ( argc < 3 || (strategy = parse_strategy(argv[2])) < 0 )
     {
         fprintf(stderr,
                 "xen-ucode: Xen microcode updating tool\n"
-                "Usage: %s <microcode blob>\n", argv[0]);
+                "Usage: %s <microcode blob> <parallel|sequential>\n", argv[0]);
         show_curr_cpu(stderr);
         return 0;
     }
@@ -113,7 +123,7 @@ int main(int argc, char *argv[])
         return errno;
     }
 
-    ret = xc_microcode_update(xch, buf, len);
+    ret = xc_microcode_update(xch, buf, len, strategy);
     if ( ret )
         fprintf(stderr, "Failed to update microcode. (err: %s)\n",
                 strerror(errno));
diff --git a/xen/arch/x86/microcode.c b/xen/arch/x86/microcode.c
index 78204b6550..e8511beb36 100644
--- a/xen/arch/x86/microcode.c
+++ b/xen/arch/x86/microcode.c
@@ -37,6 +37,8 @@
 #include <xen/earlycpio.h>
 #include <xen/watchdog.h>
 
+#include <public/platform.h>
+
 #include <asm/delay.h>
 #include <asm/msr.h>
 #include <asm/processor.h>
@@ -215,6 +217,10 @@ DEFINE_PER_CPU(struct cpu_signature, cpu_sig);
  */
 static atomic_t cpu_in, cpu_out, cpu_updated;
 
+static uint32_t application_strategy;
+/* The next CPU to perform a ucode update */
+static atomic_t next_cpu;
+
 /*
  * Return the patch with the highest revision id among all matching
  * patches in the blob. Return NULL if no suitable patch.
@@ -328,6 +334,19 @@ static int do_microcode_update(void *patch)
     if ( ret )
         return ret;
 
+    while ( application_strategy == XENPF_microcode_sequential &&
+            cpu != atomic_read(&next_cpu) )
+    {
+        finished = atomic_read(&cpu_out);
+        if ( wait_for_cpus(&next_cpu, cpu, MICROCODE_UPDATE_TIMEOUT_US) )
+        {
+            if ( atomic_read(&cpu_out) > finished )
+                continue;
+            panic("Timeout during sequential microcode update (finished %d/%d)",
+                  finished, cpu_nr);
+        }
+    }
+
     ret = microcode_ops->collect_cpu_info(&this_cpu(cpu_sig));
     /*
      * Load microcode update on only one logical processor per core.
@@ -340,6 +359,10 @@ static int do_microcode_update(void *patch)
         if ( !ret )
             atomic_inc(&cpu_updated);
     }
+
+    if ( application_strategy == XENPF_microcode_sequential )
+        atomic_set(&next_cpu, cpumask_next(cpu, &cpu_online_map));
+
     /*
      * Increase the wait timeout to a safe value here since we're serializing
      * the microcode update and that could take a while on a large number of
@@ -375,7 +398,8 @@ static int do_microcode_update(void *patch)
     return ret;
 }
 
-int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len)
+int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len,
+                     uint32_t strategy)
 {
     int ret;
     void *buffer;
@@ -388,6 +412,10 @@ int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len)
     if ( microcode_ops == NULL )
         return -EINVAL;
 
+    if ( strategy != XENPF_microcode_parallel &&
+         strategy != XENPF_microcode_sequential )
+        return -EINVAL;
+
     buffer = xmalloc_bytes(len);
     if ( !buffer )
     {
@@ -442,13 +470,19 @@ int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void) buf, unsigned long len)
         if ( cpu == cpumask_first(per_cpu(cpu_sibling_mask, cpu)) )
             nr_cores++;
 
-    printk(XENLOG_INFO "%d cores are to update their microcode\n", nr_cores);
+    printk(XENLOG_INFO "%d cores are to update their microcode %s\n", nr_cores,
+           strategy == XENPF_microcode_parallel ? "in parallel" :
+                                                  "sequentially");
 
     /*
      * We intend to disable interrupt for long time, which may lead to
      * watchdog timeout.
      */
     watchdog_disable();
+
+    application_strategy = strategy;
+    if ( strategy == XENPF_microcode_sequential )
+        atomic_set(&next_cpu, cpumask_first(&cpu_online_map));
     /*
      * Late loading dance. Why the heavy-handed stop_machine effort?
      *
diff --git a/xen/arch/x86/platform_hypercall.c b/xen/arch/x86/platform_hypercall.c
index 131e2ef1ea..9e12cca953 100644
--- a/xen/arch/x86/platform_hypercall.c
+++ b/xen/arch/x86/platform_hypercall.c
@@ -283,7 +283,8 @@ ret_t do_platform_op(XEN_GUEST_HANDLE_PARAM(xen_platform_op_t) u_xenpf_op)
 
         ret = microcode_update(
                 guest_handle_to_param(data, const_void),
-                op->u.microcode.length);
+                op->u.microcode.length,
+                op->u.microcode.strategy);
     }
     break;
 
diff --git a/xen/include/asm-x86/processor.h b/xen/include/asm-x86/processor.h
index c89b72444d..11c1f2d47f 100644
--- a/xen/include/asm-x86/processor.h
+++ b/xen/include/asm-x86/processor.h
@@ -568,7 +568,8 @@ int guest_rdmsr_xen(const struct vcpu *v, uint32_t idx, uint64_t *val);
 int guest_wrmsr_xen(struct vcpu *v, uint32_t idx, uint64_t val);
 
 void microcode_set_module(unsigned int);
-int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void), unsigned long len);
+int microcode_update(XEN_GUEST_HANDLE_PARAM(const_void), unsigned long len,
+                     uint32_t strategy);
 int early_microcode_update_cpu(void);
 int early_microcode_init(void);
 int microcode_init_intel(void);
diff --git a/xen/include/public/platform.h b/xen/include/public/platform.h
index d0b22c89d9..8cd006099c 100644
--- a/xen/include/public/platform.h
+++ b/xen/include/public/platform.h
@@ -114,6 +114,9 @@ struct xenpf_microcode_update {
     /* IN variables. */
     XEN_GUEST_HANDLE(const_void) data;/* Pointer to microcode data */
     uint32_t length;                  /* Length of microcode data. */
+#define XENPF_microcode_parallel   0
+#define XENPF_microcode_sequential 1
+    uint32_t strategy;                /* Application strategy.     */
 };
 typedef struct xenpf_microcode_update xenpf_microcode_update_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_microcode_update_t);

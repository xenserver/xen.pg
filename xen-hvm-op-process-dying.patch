Add a HVMOP which informs Xen that the current process is dying, so that
we can remember to unshadow the top-level pagetable at an appropriate time.

diff -r 2924ff4c3e27 xen/arch/x86/hvm/hvm.c
--- a/xen/arch/x86/hvm/hvm.c
+++ b/xen/arch/x86/hvm/hvm.c
@@ -4391,6 +4391,10 @@ long do_hvm_op(unsigned long op, XEN_GUE
         gdprintk(XENLOG_INFO, "Legacy windows driver quirks enabled.\n");
         break;
 
+    case HVMOP_process_dying:
+        paging_process_dying(current);
+        break;
+
     default:
     {
         gdprintk(XENLOG_DEBUG, "Bad HVM op %ld.\n", op);
diff -r 2924ff4c3e27 xen/arch/x86/mm/paging.c
--- a/xen/arch/x86/mm/paging.c
+++ b/xen/arch/x86/mm/paging.c
@@ -767,6 +767,14 @@ void pagetable_dying(struct domain *d, p
     v->arch.paging.mode->shadow.pagetable_dying(v, gpa);
 }
 
+/* Called from the guest to indicate that the current process is being 
+ * torn down (and therefore its pagetables will soon be discarded) */
+void paging_process_dying(struct vcpu *v)
+{
+    if ( paging_mode_shadow(v->domain) )
+        v->arch.paging.mode->shadow.process_dying(v);
+}
+
 /* Print paging-assistance info to the console */
 void paging_dump_domain_info(struct domain *d)
 {
diff -r 2924ff4c3e27 xen/arch/x86/mm/shadow/common.c
--- a/xen/arch/x86/mm/shadow/common.c
+++ b/xen/arch/x86/mm/shadow/common.c
@@ -582,6 +582,7 @@ static inline void _sh_resync_l1(struct 
     else if ( pg->shadow_flags & SHF_L1_64 )
         SHADOW_INTERNAL_NAME(sh_resync_l1, 4)(v, gmfn, snpmfn);
 #endif
+    v->domain->arch.paging.shadow.process_dying_op = 0;
 }
 
 
diff -r 2924ff4c3e27 xen/arch/x86/mm/shadow/multi.c
--- a/xen/arch/x86/mm/shadow/multi.c
+++ b/xen/arch/x86/mm/shadow/multi.c
@@ -4115,7 +4115,11 @@ sh_set_toplevel_shadow(struct vcpu *v,
         smfn = sh_make_shadow(v, gmfn, root_type);
     }
     ASSERT(mfn_valid(smfn));
-    
+
+    /* Remember if we've been told that this process is being torn down */
+    v->arch.paging.shadow.process_dying 
+        = !!(mfn_to_page(gmfn)->shadow_flags & SHF_process_dying);
+
     /* Pin the shadow and put it (back) on the list of pinned shadows */
     if ( sh_pin(v, smfn) == 0 )
     {
@@ -4690,6 +4694,43 @@ int sh_remove_l3_shadow(struct vcpu *v, 
 #endif /* 64bit guest */ 
 
 /**************************************************************************/
+/* Function for the guest to inform us that the current process is being
+ * torn down.  We remember that as a hint to unshadow its pagetables 
+ * soon, and in the meantime we unhook its top-level user-mode entries. */
+
+static void sh_process_dying(struct vcpu *v)
+{
+    int i = 0;
+    mfn_t smfn, gmfn;
+
+    paging_lock(v->domain);
+
+#if (SHADOW_PAGING_LEVELS == 3) 
+    for ( i = 0; i < 4; i ++ )
+#endif
+    {
+        smfn = _mfn(pagetable_get_pfn(v->arch.shadow_table[i]));
+        if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )
+        {
+            gmfn = _mfn(mfn_to_page(smfn)->v.sh.back);
+            mfn_to_page(gmfn)->shadow_flags |= SHF_process_dying;
+            shadow_unhook_mappings(v, smfn, 1/* user pages only */);
+            /* Now flush the TLB: we removed toplevel mappings. */
+            flush_tlb_mask(v->domain->domain_dirty_cpumask);
+        }
+    }
+
+    /* Remember that we've seen the guest use this interface, so we
+     * can rely on it using it in future, instead of guessing at
+     * when processes are being torn down. */
+    v->domain->arch.paging.shadow.process_dying_op = 1;
+
+    v->arch.paging.shadow.process_dying = 1;
+
+    paging_unlock(v->domain);
+}
+
+/**************************************************************************/
 /* Function for the guest to inform us that a process is being torn
  * down.  We remember that as a hint to unshadow its pagetables soon,
  * and in the meantime we unhook its top-level user-mode entries. */
@@ -5468,6 +5509,7 @@ const struct paging_mode sh_paging_mode 
     .shadow.guess_wrmap            = sh_guess_wrmap,
 #endif
     .shadow.pagetable_dying        = sh_pagetable_dying,
+    .shadow.process_dying          = sh_process_dying,
     .shadow.shadow_levels          = SHADOW_PAGING_LEVELS,
 };
 
diff -r 2924ff4c3e27 xen/arch/x86/mm/shadow/private.h
--- a/xen/arch/x86/mm/shadow/private.h
+++ b/xen/arch/x86/mm/shadow/private.h
@@ -285,6 +285,8 @@ static inline int sh_type_has_up_pointer
 
 #define SHF_pagetable_dying (1u<<31)
 
+#define SHF_process_dying (1u<<31)
+
 static inline int sh_page_has_multiple_shadows(struct page_info *pg)
 {
     u32 shadows;
@@ -370,7 +372,7 @@ int shadow_write_guest_entry(struct vcpu
 int shadow_cmpxchg_guest_entry(struct vcpu *v, intpte_t *p,
                                intpte_t *old, intpte_t new, mfn_t gmfn);
 
-/* Unhook the non-Xen mappings in this top-level shadow mfn.
+/* Unhook the non-Xen mappings in this top-level shadow mfn.  
  * With user_only == 1, unhooks only the user-mode mappings. */
 void shadow_unhook_mappings(struct vcpu *v, mfn_t smfn, int user_only);
 
diff -r 2924ff4c3e27 xen/include/asm-x86/domain.h
--- a/xen/include/asm-x86/domain.h
+++ b/xen/include/asm-x86/domain.h
@@ -120,6 +120,9 @@ struct shadow_domain {
     int oos_off;
 
     int pagetable_dying_op;
+
+    /* Process dying hypercall detected. */
+    int process_dying_op;
 };
 
 struct shadow_vcpu {
@@ -150,6 +153,9 @@ struct shadow_vcpu {
     } oos_fixup[SHADOW_OOS_PAGES];
 
     int pagetable_dying;
+
+    /* Process is marked as dying by PV drivers. */
+    int process_dying;
 };
 
 /************************************************/
diff -r 2924ff4c3e27 xen/include/asm-x86/paging.h
--- a/xen/include/asm-x86/paging.h
+++ b/xen/include/asm-x86/paging.h
@@ -96,6 +96,7 @@ struct shadow_paging_mode {
     int           (*guess_wrmap           )(struct vcpu *v, 
                                             unsigned long vaddr, mfn_t gmfn);
     void          (*pagetable_dying       )(struct vcpu *v, paddr_t gpa);
+    void          (*process_dying         )(struct vcpu *v);
     /* For outsiders to tell what mode we're in */
     unsigned int shadow_levels;
 };
@@ -364,6 +365,10 @@ void paging_write_p2m_entry(struct p2m_d
  * torn down and its pagetables will soon be discarded */
 void pagetable_dying(struct domain *d, paddr_t gpa);
 
+/* Called from the guest to indicate that the current process is being 
+ * torn down (and therefore its pagetables will soon be discarded) */
+void paging_process_dying(struct vcpu *v);
+
 /* Print paging-assistance info to the console */
 void paging_dump_domain_info(struct domain *d);
 void paging_dump_vcpu_info(struct vcpu *v);
diff -r 2924ff4c3e27 xen/include/public/hvm/hvm_op.h
--- a/xen/include/public/hvm/hvm_op.h
+++ b/xen/include/public/hvm/hvm_op.h
@@ -131,6 +131,9 @@ DEFINE_XEN_GUEST_HANDLE(xen_hvm_set_mem_
 
 #endif /* defined(__XEN__) || defined(__XEN_TOOLS__) */
 
+/* Hint from PV drivers for process destruction. */
+#define HVMOP_process_dying        0x102
+
 /* Hint from PV drivers for pagetable destruction. */
 #define HVMOP_pagetable_dying        9
 struct xen_hvm_pagetable_dying {

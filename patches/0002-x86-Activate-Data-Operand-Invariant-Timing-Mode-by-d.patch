From 0df6fc66f982df5ec39a56bcec58ad0176809a03 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Tue, 4 Oct 2022 14:41:33 +0100
Subject: x86: Activate Data Operand Invariant Timing Mode by default
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Intel IceLake and later CPUs have microarchitectural behaviours which cause
data-dependent timing behaviour.  This is not an issue for 99% of software,
but it is a problem for cryptography routines.  On these CPUs, a new
architectural feature, DOITM, was retrofitted in microcode.

For now, Xen can't enumerate DOITM to guest kernels; getting this working is
still in progress.  The consequence is that guest kernels will incorrectly
conclude that they are safe.

To maintain the safety of current software, activate DOITM unilaterally.  This
will be relaxed in the future when we can enumerate the feature properly to
guests.

As an emergency stopgap, this behaviour can be disabled by specifying
`cpuid=no-doitm` on Xen's command line, but is not guaranteed ABI moving
forward.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
diff --git a/xen/arch/x86/cpu-policy.c b/xen/arch/x86/cpu-policy.c
index e28bfad2f61f..83dd2a39840b 100644
--- a/xen/arch/x86/cpu-policy.c
+++ b/xen/arch/x86/cpu-policy.c
@@ -109,7 +109,12 @@ static void __init _parse_xen_cpuid(
     const char *name, unsigned int feat, bool val)
 {
     if ( unlikely(feat == ~0u) )
+    {
+        if ( strcmp(name, "doitm") == 0 )
+            opt_doitm = val;
+
         return;
+    }
 
     if ( !val )
         setup_clear_cpu_cap(feat);
diff --git a/xen/arch/x86/cpu/common.c b/xen/arch/x86/cpu/common.c
index b6de0b51a233..c907e6e098ab 100644
--- a/xen/arch/x86/cpu/common.c
+++ b/xen/arch/x86/cpu/common.c
@@ -206,6 +206,34 @@ void ctxt_switch_levelling(const struct vcpu *next)
 		alternative_vcall(ctxt_switch_masking, next);
 }
 
+bool __read_mostly opt_doitm = true;
+
+static void doitm_init(void)
+{
+    uint64_t val;
+
+    if ( !opt_doitm || !cpu_has_arch_caps )
+        return;
+
+    rdmsrl(MSR_ARCH_CAPABILITIES, val);
+    if ( !(val & ARCH_CAPS_DOITM) )
+        return;
+
+    /*
+     * We are currently unable to enumerate MSR_ARCH_CAPS to guest.  As a
+     * consequence, guest kernels will believe they're safe even when they are
+     * not.
+     *
+     * Until we can enumerate DOITM properly for guests, set it unilaterally.
+     * This prevents otherwise-correct crypto from becoming vulnerable to
+     * timing sidechannels.
+     */
+
+    rdmsrl(MSR_UARCH_MISC_CTRL, val);
+    val |= UARCH_CTRL_DOITM;
+    wrmsrl(MSR_UARCH_MISC_CTRL, val);
+}
+
 bool_t opt_cpu_info;
 boolean_param("cpuinfo", opt_cpu_info);
 
@@ -505,6 +533,7 @@ void identify_cpu(struct cpuinfo_x86 *c)
 	/* Now the feature flags better reflect actual CPU features! */
 
 	xstate_init(c);
+	doitm_init();
 
 #ifdef NOISY_CAPS
 	printk(KERN_DEBUG "CPU: After all inits, caps:");
diff --git a/xen/include/asm-x86/msr-index.h b/xen/include/asm-x86/msr-index.h
index e770feede2f8..4f9fc771367a 100644
--- a/xen/include/asm-x86/msr-index.h
+++ b/xen/include/asm-x86/msr-index.h
@@ -62,6 +62,7 @@
 #define ARCH_CAPS_IF_PSCHANGE_MC_NO	(_AC(1, ULL) << 6)
 #define ARCH_CAPS_TSX_CTRL		(_AC(1, ULL) << 7)
 #define ARCH_CAPS_TAA_NO		(_AC(1, ULL) << 8)
+#define ARCH_CAPS_DOITM			(_AC(1, ULL) << 12)
 #define ARCH_CAPS_SBDR_SSDP_NO		(_AC(1, ULL) << 13)
 #define ARCH_CAPS_FBSDP_NO		(_AC(1, ULL) << 14)
 #define ARCH_CAPS_PSDP_NO		(_AC(1, ULL) << 15)
@@ -249,6 +250,9 @@
 #define MSR_PL3_SSP                         0x000006a7
 #define MSR_INTERRUPT_SSP_TABLE             0x000006a8
 
+#define MSR_UARCH_MISC_CTRL                 0x00001b01
+#define  UARCH_CTRL_DOITM                   (_AC(1, ULL) <<  0)
+
 /* K7/K8 MSRs. Not complete. See the architecture manual for a more
    complete list. */
 #define MSR_K7_EVNTSEL0			0xc0010000
diff --git a/xen/include/asm-x86/processor.h b/xen/include/asm-x86/processor.h
index 7b31c7eea230..31430d888541 100644
--- a/xen/include/asm-x86/processor.h
+++ b/xen/include/asm-x86/processor.h
@@ -621,6 +621,8 @@ void set_in_mcu_opt_ctrl(uint32_t mask, uint32_t val);
 
 void amd_check_zenbleed(void);
 
+extern bool opt_doitm;
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* __ASM_X86_PROCESSOR_H */
diff --git a/xen/tools/gen-cpuid.py b/xen/tools/gen-cpuid.py
index 01587364f1bd..2bd6fd8db6c4 100755
--- a/xen/tools/gen-cpuid.py
+++ b/xen/tools/gen-cpuid.py
@@ -318,6 +318,8 @@ def crunch_numbers(state):
     # specially
     #
     pseduo_names = (
+        # Data Operand Invariant Timing Mode.  Lives in MSR_ARCH_CAPS
+        "doitm",
     )
 
     for n in pseduo_names:
